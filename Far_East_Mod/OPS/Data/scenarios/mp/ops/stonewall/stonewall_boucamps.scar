-------------------------------------------------------------------------
-------------------------------------------------------------------------

-- Mission Name

-------------------------------------------------------------------------
-------------------------------------------------------------------------

import("ScarUtil.scar")
import("Stonewall_CombatPlanData.scar")
import("Stonewall_Sound_Data.scar")
import("fe_achive.scar");

-------------------------------------------------------------------------

-- [[ SETUP ]]

-------------------------------------------------------------------------

function OnGameSetup()
	World_EnableReplacementObjectForEmptyPlayers(false);
	print("Launching Stonewall with FEW loaded!");
end

function OnGameRestore()
	--player1 = World_GetPlayerAt(1)
	--player2 = World_GetPlayerAt(2)
	-- player3 = World_GetPlayerAt(3)
	
	-- function takes care of restoring all global mission parameters after a save/load
	--Game_DefaultGameRestore()
end

-------------------------------------------------------------------------

-- [[ ONINIT ]]

-------------------------------------------------------------------------
function WinConditionOverride()
	g_VPConditionsLoaded = false
	g_CheckAnnihilate = false
end

function OnInit()

	g_SpawnPosition1 = mkr_CreepSpawn1
	g_SpawnPosition2 = mkr_CreepSpawn2
	g_SpawnDestination = mkr_CreepDestination1
	g_CountdownTime = 90
	
	--[[ SETUP SOUND ]]
	Invasion_PrecacheSound()
	
	--[[ PRESET GAME STATE ]]
	--Game_FadeToBlack(true, 0)
	-- adding a fix to prevent the player from opening the main menu while the screen is black
	--UI_BindingSetEnabled( "system_menu", false)
	
	Bouc_Debug()
	Bouc_ObjectiveRegister()
	Bouc_ModifyStats()
	Rule_InvasionPlayerDef()
	Bouc_CpuInit()
	Bouc_Difficulty()
	Bouc_MissionPreset()
	Bouc_MissionStart()

end

Scar_AddInit(OnInit)

function Bouc_Debug()
	if Misc_IsCommandLineOptionSet("debug") then
		g_debug = true
	end
	if Misc_IsCommandLineOptionSet("nis") then
	end
end

function Bouc_ObjectiveRegister()
	Initialize_OBJ_Defend_HQ()
end

function Bouc_ModifyStats()
end

function Rule_InvasionPlayerDef()

	FOW_RevealMarker(mkr_FOWBaseReveal1, -1)

	t_PlayerIDInfo = {}
	t_PlayerHumanInfo = {}

	g_numplayer = World_GetPlayerCount()
	g_PlayerTeam = 1
	g_CreepTeam = 0
	g_CreepDefined = false
	g_TeamsDefined = false
	g_SinglePlayer = false
	
	local l_ActorDefined = false
	local l_FirstHumanID = false
	local l_FirstHumanTeam = false
	UI_EnableResourceTypeKicker(RT_Action, false)
	
	for i = 1 , g_numplayer do
		
		local player = World_GetPlayerAt(i)
		local playerteam = Player_GetTeam(player)
		
		if Player_IsHuman(player) then
			l_FirstHumanID = player
			l_FirstHumanTeam = playerteam
			break
		end
	end
	
	AI_EnableAll(false)
	
	for i = 1 , g_numplayer do
		
		local player = World_GetPlayerAt(i)	
		local playerteam = Player_GetTeam(player)
		
		t_TempPlayerInfo = {playerID = player, team = playerteam, isHuman = true}
		
		
		table.insert(t_PlayerIDInfo, t_TempPlayerInfo)
				
		if g_TeamsDefined == false then
		
			if Player_IsHuman(player) and (Player_IsAllied(player, l_FirstHumanID) == true) then
				print("human")
				print(Player_GetTeam(player))
				print("player number is: "..i)
				if Player_GetTeam(player) == 1 then
					
					g_PlayerTeam = 1
					g_CreepTeam = 0
					g_TeamsDefined = true
					
				elseif Player_GetTeam(player) == 0 then
					
					g_PlayerTeam = 0
					g_CreepTeam = 1
					g_TeamsDefined = true
					
				end
				
			elseif (Player_IsHuman(player) == false) and (Player_IsAllied(player, l_FirstHumanID) == false) then-- not human
			
				print("creep")
				print(Player_GetTeam(player))
				print("creep number is: "..i)
				if Player_GetTeam(player) == 1 then
					
					g_CreepTeam = 1
					g_PlayerTeam = 0
					g_TeamsDefined = true
					
				elseif Player_GetTeam(player) == 0 then
					
					g_CreepTeam = 0
					g_PlayerTeam = 1
					g_TeamsDefined = true
					
				end
				
			end
			
		end
		
		-- checks to see if player is human, if not then give it special properties, otherwise grant stuff for humans
		if Player_IsHuman(player) and (Player_GetTeam(player) == g_PlayerTeam) then --if human player
			print("human player in")
			
			Modify_PlayerResourceRate(player, RT_Action, 0.0) -- stop AP from being gained
			Modify_Upkeep(player, 0.10 )
			Modify_PlayerResourceRate( player, RT_Manpower, 0.30) -- reduce manpower resource rate to a trickle -- 0.25 
			
			Player_SetResource(player, RT_Manpower, 300) -- set initial manpower resource
			Player_SetResource(player, RT_Munition, 200) -- set initial munition resource
			
			--Player_SetPopCapOverride(player, 30) -- set initial maximum pop cap, originally at 75 
			Player_SetUpgradeAvailability(player, UPG.CW.CONVERT_AMBIENT_BUILDING, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(player, UPG.ALLIES.CONVERT_AMBIENT_BUILDING, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(player, UPG.AXIS.CONVERT_AMBIENT_BUILDING, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(player, UPG.ELITE.CONVERT_AMBIENT_BUILDING, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			
			if l_ActorDefined == false then	
				if Player_GetRaceName(player) == "allies" then
					
					g_Actor = ACTOR.GenericAlly
					l_ActorDefined = true
					
				elseif Player_GetRaceName(player) == "axis" then
					
					g_Actor = ACTOR.GenericAxis
					l_ActorDefined = true
				else
					
					g_Actor = ACTOR.GenericAlly
					l_ActorDefined = true
				end
			end
			
			
			-- the following are race specific upgrades and resource settings
			if Player_GetRaceName(player) == "allies" then
				
				Cmd_InstantUpgrade(player, UPG.COHO.INVASION.ALLIES_BUILDING_INIT_SOLDIER)
				Player_SetResource(player, RT_Fuel, 200) -- set initial fuel resource
				
			elseif Player_GetRaceName(player) == "axis" then
				
				Cmd_InstantUpgrade(player, UPG.COHO.INVASION.AXIS_BUILDING_INIT_SOLDIER)
				Cmd_InstantUpgrade(player, UPG.AXIS.PHASE2)
				Cmd_InstantUpgrade(player, UPG.AXIS.PHASE3)
				Cmd_InstantUpgrade(player, UPG.AXIS.PHASE4)
				Player_SetResource(player, RT_Fuel, 0) -- set initial fuel resource
			else
				
				Cmd_InstantUpgrade(player, UPG.COHO.INVASION.ALLIES_BUILDING_INIT_SOLDIER)
				--Cmd_InstantUpgrade(player, UPG.ALLIES.GRENADE)
			end
			
			t_TempHumanInfo = {
				playerID = player, isHuman = true, squadCount = 0, manpowerCount = 500, hasNothing = false, building = EGroup_CreateIfNotFound("tempbuilding"), 
				secondaryBuilding = EGroup_CreateIfNotFound("tempsecondarybuilding"), individualTotalScore = 0, killCount = 0, killCountScore = 0, squadCountScore = 0, unitsLost = 0, unitsLostPenalty = 0,
				objectiveName = false, bonusScore = 0, secondaryOwned = {false, false, false, false}, manorOwned = false, abilityStatus = {false, false, false, false}, abilityFlashID = nil, currentAbility = nil,
				hintID = nil
			}
			
			table.insert(t_PlayerHumanInfo, t_TempHumanInfo)
--~ 			
			
		elseif Player_IsHuman(player) and ((Player_GetTeam(player) == g_PlayerTeam) == false) then --if human player but not on player team
			
			Modify_PlayerResourceRate(player, RT_Action, 0.0) -- stop AP from being gained
			Modify_PlayerResourceRate( player, RT_Manpower, 0.0) -- reduce manpower resource rate to a trickle
			
			Player_SetResource(player, RT_Manpower, 0) -- set initial manpower resource
			Player_SetResource(player, RT_Fuel, 0) -- set initial fuel resource
			Player_SetResource(player, RT_Munition, 0) -- set initial munition resource
			
		elseif Player_IsHuman(player) == false then  -- if non-human player -- grabs first non human player that is not allied with player and makes that the creep, this has to be explicit
			print("non human is in")
					
 			if (Player_GetRaceName(player) == TRACE_ALLIES) and g_CreepDefined == false and (Player_GetTeam(player) == g_CreepTeam) then
				
				g_CreepPlayer = player
				g_CreepDefined = true
				t_PlayerIDInfo[i].isHuman = false
				
				Cmd_InstantUpgrade(g_CreepPlayer, UPG.ALLIES.GRENADE)
				print("allied creep defined")
			elseif (Player_GetRaceName(player) == TRACE_AXIS) and g_CreepDefined == false and (Player_GetTeam(player) == g_CreepTeam) then
				
				g_CreepPlayer = player
				g_CreepDefined = true
				t_PlayerIDInfo[i].isHuman = false
				
				print("axis creep defined")
				
			end
			
			Player_SetPopCapOverride(player, 500)
			
			Modify_PlayerResourceRate(player, RT_Action, 0.0) -- stop AP from being gained
			Modify_PlayerResourceRate( player, RT_Manpower, 0.0) -- reduce manpower resource rate to a trickle
			
			Player_SetResource(player, RT_Manpower, 0) -- set initial manpower resource
			Player_SetResource(player, RT_Fuel, 0) -- set initial fuel resource
			Player_SetResource(player, RT_Munition, 10000) -- set initial munition resource
			
			Player_AddAbility(player, ABILITY.COHO.UMS.INVASION.CREEP_OFFMAP_ARTILLERY)
			Player_AddAbility(player, ABILITY.SP.SINGLE_MORTAR_SMOKE)
		end
		
	end
	
	
	g_NumberOfHumans = table.getn(t_PlayerHumanInfo) -- number of humans (that have intact buildings)
	g_TotalNumberOfHumans = table.getn(t_PlayerHumanInfo) -- base number of humans in game, used for comparison purposes
	print("number of humans "..g_NumberOfHumans)
	g_HasNothingCount = 0 -- number of human players that have neither units nor manpower
	g_HumansHaveNothing = false -- if all human playerse have neither units nor manpower this flag is set to true
	
	teg_StuffSpawn = EGroup_CreateTable("eg_StuffSpawn%d", table.getn(t_PlayerIDInfo)) -- defines the spawning building EGroupID
	
	tmkr_PlayerInfantryBuilding = {mkr_PlayerInfantryBuilding1, mkr_PlayerInfantryBuilding2, mkr_PlayerInfantryBuilding3, mkr_PlayerInfantryBuilding4}
	
	local l_VehicleSpawnBlueprint = false
	local l_InfantrySpawnBlueprint = false
	local l_ControlStructureDefined = false
	
	for i = 1, table.getn(t_PlayerHumanInfo) do
		
		if Player_GetRaceName(t_PlayerHumanInfo[i].playerID) == "allies" then
			
			--l_InfantrySpawnBlueprint = EBP.SP.ALLY_BARRACKS_INVASION	
			--l_VehicleSpawnBlueprint = EBP.SP.ALLY_2ND_MOTORPOOL_INVASION
			l_InfantrySpawnBlueprint = EBP.SP.ALLY_2ND_MOTORPOOL_INVASION
			
			
		elseif Player_GetRaceName(t_PlayerHumanInfo[i].playerID) == "axis" then
			
			--l_InfantrySpawnBlueprint = EBP.SP.AXIS_BARRACKS_INVASION
			l_InfantrySpawnBlueprint = EBP.SP.AXIS_COMMAND_INVASION
			
			
			
		else
			--l_InfantrySpawnBlueprint = EBP.SP.ALLY_BARRACKS_INVASION	
			l_InfantrySpawnBlueprint = EBP.SP.ALLY_2ND_MOTORPOOL_INVASION
			
			
		end
		
		if l_ControlStructureDefined == false then	
			
			EGroup_InstantCaptureStrategicPoint(eg_ControlStructure, t_PlayerHumanInfo[i].playerID)
			l_ControlStructureDefined = true
			
		end
		
		t_PlayerHumanInfo[i].building = teg_StuffSpawn[i]
		t_PlayerHumanInfo[i].destroyed = false
		t_PlayerHumanInfo[i].destroyedpath = soundData.building.HQ.destroyed
		t_PlayerHumanInfo[i].underattackpath = soundData.building.HQ.underattack
		t_PlayerHumanInfo[i].lowhealthpath = soundData.building.HQ.lowhealth
		t_PlayerHumanInfo[i].timer = "HQtimer"..i
		t_PlayerHumanInfo[i].owner = t_PlayerHumanInfo[i].playerID
		Timer_Start(t_PlayerHumanInfo[i].timer, 1)
		
		Util_CreateEntities(t_PlayerHumanInfo[i].playerID, t_PlayerHumanInfo[i].building, l_InfantrySpawnBlueprint,  tmkr_PlayerInfantryBuilding[i], 1)
		
		-- reduce the player pop cap slightly in a 3 or 4 player game
		if g_NumberOfHumans >= 3 then
			local modifier = Modifier_Create(MAT_Player, "modifiers\\personnel_cap_player_modifier.lua", MUT_Addition, false, -5, "")
			Modifier_ApplyToPlayer(modifier, t_PlayerHumanInfo[i].playerID)
		end
		
	end

	t_TargetTable = {
		
		{name = eg_bank, destroyed = false, message = {{g_Actor, 10000010}}, buildingtype = "bank", hintpointID = nil, hinttext = 10000060, captured = false,
			underattackpath = soundData.building.bank.underattack, capturedpath = soundData.building.bank.captured, destroyedpath = soundData.building.bank.destroyed,
			timer = "banktimer", owner = false}, 
		{name = eg_church, destroyed = false, message = {{g_Actor, 10000011}}, buildingtype = "church", hintpointID = nil, hinttext = 10000062, captured = false,
			underattackpath = soundData.building.church.underattack, capturedpath = soundData.building.church.captured, destroyedpath = soundData.building.church.destroyed,
			timer = "churchtimer", owner = false}, 
		{name = eg_manor, destroyed = false, message = {{g_Actor, 10000012}}, buildingtype = "manor", hintpointID = nil, hinttext = 10000061, captured = false,
			underattackpath = soundData.building.manor.underattack, capturedpath = soundData.building.manor.captured, destroyedpath = soundData.building.manor.destroyed,
			timer = "manortimer", owner = false}, 
		{name = eg_garage, destroyed = false, message = {{g_Actor, 10000013}}, buildingtype = "garage", hintpointID = nil, hinttext = 10000063, captured = false,
			underattackpath = soundData.building.garage.underattack, capturedpath = soundData.building.garage.captured, destroyedpath = soundData.building.garage.destroyed,
			timer = "garagetimer", owner = false}, 
		
	}
	
	-- initializes attack timer
	for o, p in pairs(t_TargetTable) do
		
		Timer_Start(p.timer, 1)
		
	end
	
	eg_Player1SecondaryBuildings = EGroup_CreateIfNotFound("eg_Player1SecondaryBuildings")
	eg_Player2SecondaryBuildings = EGroup_CreateIfNotFound("eg_Player2SecondaryBuildings")
	eg_Player3SecondaryBuildings = EGroup_CreateIfNotFound("eg_Player3SecondaryBuildings")
	eg_Player4SecondaryBuildings = EGroup_CreateIfNotFound("eg_Player4SecondaryBuildings")

	eg_AllSecondaryBuildings = EGroup_CreateIfNotFound("eg_AllSecondaryBuildings")
	
	for q, r in pairs(t_TargetTable) do
		EGroup_AddEGroup(eg_AllSecondaryBuildings, r.name)
	end
	
	g_HintPointRemoved = false
	
	-- the following manually assigns the outlying buildings to other people, depending on number of human players.
	-- not in a loop on purpose because the numbers change
	if g_NumberOfHumans == 1 then
		
		EGroup_SetPlayerOwner(t_TargetTable[1].name, t_PlayerHumanInfo[1].playerID)
		EGroup_AddEGroup(eg_Player1SecondaryBuildings, t_TargetTable[1].name)
		Cmd_InstantUpgrade(t_TargetTable[1].name, UPG.COHO.INVASION.CONVERT_AMBIENT_BUILDING_NO_PREREQS)
		
		EGroup_SetPlayerOwner(t_TargetTable[2].name, t_PlayerHumanInfo[1].playerID)
		EGroup_AddEGroup(eg_Player1SecondaryBuildings, t_TargetTable[2].name)
		Cmd_InstantUpgrade(t_TargetTable[2].name, UPG.COHO.INVASION.CONVERT_AMBIENT_BUILDING_NO_PREREQS)
		
		EGroup_SetPlayerOwner(t_TargetTable[3].name, t_PlayerHumanInfo[1].playerID)
		EGroup_AddEGroup(eg_Player1SecondaryBuildings, t_TargetTable[3].name)
		Cmd_InstantUpgrade(t_TargetTable[3].name, UPG.COHO.INVASION.CONVERT_AMBIENT_BUILDING_NO_PREREQS)
		
		EGroup_SetPlayerOwner(t_TargetTable[4].name, t_PlayerHumanInfo[1].playerID)
		EGroup_AddEGroup(eg_Player1SecondaryBuildings, t_TargetTable[4].name)
		Cmd_InstantUpgrade(t_TargetTable[4].name, UPG.COHO.INVASION.CONVERT_AMBIENT_BUILDING_NO_PREREQS)
		
		t_PlayerHumanInfo[1].secondaryBuilding = eg_Player1SecondaryBuildings
		
	elseif g_NumberOfHumans == 2 then
		
		t_PlayerHumanInfo[1].secondaryBuilding = eg_Player1SecondaryBuildings
		t_PlayerHumanInfo[2].secondaryBuilding = eg_Player2SecondaryBuildings
		
	elseif g_NumberOfHumans == 3 then
		
		t_PlayerHumanInfo[1].secondaryBuilding = eg_Player1SecondaryBuildings
		t_PlayerHumanInfo[2].secondaryBuilding = eg_Player2SecondaryBuildings
		t_PlayerHumanInfo[3].secondaryBuilding = eg_Player3SecondaryBuildings
		
	elseif g_NumberOfHumans == 4 then
		
		t_PlayerHumanInfo[1].secondaryBuilding = eg_Player1SecondaryBuildings
		t_PlayerHumanInfo[2].secondaryBuilding = eg_Player2SecondaryBuildings
		t_PlayerHumanInfo[3].secondaryBuilding = eg_Player3SecondaryBuildings
		t_PlayerHumanInfo[4].secondaryBuilding = eg_Player4SecondaryBuildings
		
	else	
		-- do nothing
	end

	Rule_AddDelayedInterval(Rule_SecondaryBuildingOwnerCheck, 1, 1)
	Rule_AddDelayedInterval(Rule_ManorSpecialAdd, 1, 1)
	
	
	if g_NumberOfHumans == 1 then
		
		--do nothing, don't limit number of popcap upgrades
		
	elseif g_NumberOfHumans == 2 then
		
		for k, v in pairs(t_PlayerHumanInfo) do
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE6, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE5, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE4, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Modify_PlayerResourceRate(v.playerID, RT_Manpower, 0.82, MUT_Multiplication)
		end
		
	elseif g_NumberOfHumans == 3 then
		
		for k, v in pairs(t_PlayerHumanInfo) do
			
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE6, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE5, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE4, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE3, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Modify_PlayerResourceRate(v.playerID, RT_Manpower, 0.66, MUT_Multiplication)
			
		end
		
	elseif g_NumberOfHumans == 4 then
		
		for k, v in pairs(t_PlayerHumanInfo) do
			
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE6, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE5, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE4, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE3, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Player_SetUpgradeAvailability(v.playerID, UPG.COHO.INVASION.UNIVERSAL_POPCAP_UPGRADE2, ITEM_REMOVED) -- prevents upgrade ability from being assigned to player
			Modify_PlayerResourceRate(v.playerID, RT_Manpower, 0.5, MUT_Multiplication)
			
		end
		
	end
	
	-- the following adds engineers to the map
	
	sg_PlayerEngineers = SGroup_CreateTable("sg_Player%dEngineer", g_NumberOfHumans)
	
	for k, v in pairs(t_PlayerHumanInfo) do
		
		if Player_GetRaceName(v.playerID) == TRACE_ALLIES then
			
			Util_CreateSquads(v.playerID, sg_PlayerEngineers[k], SBP.COHO.INVASION_ALLIES_ENGINEER, mkr_engineerspawn, nil, 1)
			
		elseif Player_GetRaceName(v.playerID) == TRACE_AXIS then
			
			Util_CreateSquads(v.playerID, sg_PlayerEngineers[k], SBP.COHO.INVASION_AXIS_PIONEER, mkr_engineerspawn, nil, 1)
			
		end
		
	end
	
	
	-- the following enables or disables the repair station upgrade or the repair facility upgrade depending on number of players
	if g_NumberOfHumans >= 3 then
		
		for k, v in pairs(t_PlayerHumanInfo) do
			
			Player_SetUpgradeAvailability(v.playerID, BP_GetUpgradeBlueprint("upgrade/allies/cp_aide_station_upgrade_axis.lua"), ITEM_REMOVED)
			Player_SetUpgradeAvailability(v.playerID, BP_GetUpgradeBlueprint("upgrade/axis/axis_bunker_to_repair_facility.lua"), ITEM_REMOVED)
			
		end
		
	end
	
	-----------------------
	-- Added Feb 17 by Ryan
	
	KillTeamInit()
	Rule_AddInterval(BaseChecker, 1)
	
	
	
end

-- tracks owner status of secondary building
function Rule_SecondaryBuildingOwnerCheck()

	for k, v in pairs(t_TargetTable) do
		
		for x, y in pairs(t_PlayerHumanInfo) do
			-- compares values to see if the building in question is still there, if someone owns it , and if its "owned" flag has been set
			if EGroup_IsEmpty(v.name) == false and Player_OwnsEGroup(y.playerID, v.name) and y.secondaryOwned[k] == false then
				-- upgrade to forward barracks
				Cmd_InstantUpgrade(v.name, UPG.COHO.INVASION.CONVERT_AMBIENT_BUILDING_NO_PREREQS)
				
				EGroup_AddEGroup(y.secondaryBuilding, v.name)
				y.secondaryOwned[k] = true
				v.owner = y.playerID
				
			-- if the building has an owner and the owner is dead/dropped and its "owned" status is true
			elseif EGroup_IsEmpty(v.name) == false 
			and v.owner ~= false and Player_IsAlive(v.owner) == false --[[previous owner]]  
			and y.secondaryOwned[k] == true then
				
				-- resets a building's status so that it can be owned again with the forward barrack upgrade
				EGroup_RemoveUpgrade(v.name, UPG.COHO.INVASION.CONVERT_AMBIENT_BUILDING_NO_PREREQS)
				EGroup_RemoveGroup(y.secondaryBuilding, v.name)
				y.secondaryOwned[k] = false
				v.owner = false
			end
			
		end
		
	end

end

-- if player owns the manor, then apply the special popcap upgrade
function Rule_ManorSpecialAdd()

	for x, y in pairs(t_PlayerHumanInfo) do
		
		if EGroup_IsEmpty(eg_manor) == false and (Player_OwnsEGroup(y.playerID, eg_manor) and y.manorOwned == false) then
			
			Cmd_InstantUpgrade(y.playerID, UPG.COHO.INVASION.MANOR_UPGRADE)
			
			y.manorOwned = true
			
			break
			
		elseif EGroup_IsEmpty(eg_manor) == false and (Player_OwnsEGroup(y.playerID, eg_manor) == false and y.manorOwned == true) then
			
			Cmd_InstantUpgrade(y.playerID, UPG.COHO.INVASION.MANOR_DOWNGRADE)
			
			y.manorOwned = false
			
			break
			
		elseif EGroup_IsEmpty(eg_manor) == true then
			
			for a, b in pairs(t_PlayerHumanInfo) do -- do a quick check on all players to make sure we remove the +10 popcap from players if the building is empty.  this repeated for loop is deliberate.
				
				if b.manorOwned == true then
					
					Cmd_InstantUpgrade(b.playerID, UPG.COHO.INVASION.MANOR_DOWNGRADE)
					
				end
				
			end
			Rule_RemoveMe()
			
			break
		end
	end
	
end


-- start building hint points
function Rule_CreateBuildingHintPoints()
	
	if g_NumberOfHumans >= 2 then
		
		t_DisplayHintText = {
			
			{g_Actor, 10000065}, -- Beginning Text
			
		}
		
		--Util_AutoIntel(t_DisplayHintText)
		
		for q, r in pairs(t_TargetTable) do
			
			r.hintpointID = HintPoint_Add(r.name, true, r.hinttext)
			
			FOW_RevealEGroup(r.name, 120)
			UI_CreateMinimapBlip(r.name, 10, BT_CaptureHerePing)
			--Objective_AddPing(OBJ_Defend_HQ, EGroup_GetPosition(r.name))
		end
		
		-- kicks off blips too
		Rule_AddInterval(Rule_MiniBlips, 10)
		
	end
	
end

function Rule_SinglePlayerBuildingHintPoints()

	if g_NumberOfHumans == 1 then
		
		for q, r in pairs(t_TargetTable) do
			r.hintpointID = HintMouseover_Add(r.hinttext, r.name, 10, true )
			
		end
		
	end
end

-- creates "capture me" building blips, which will disappear once the initial countdown is over
function Rule_MiniBlips()

	if g_NumberOfHumans >= 2 then
		if math.floor(Timer_GetRemaining("HintpointRemoval")) <= 0 then
			
			Rule_RemoveMe()
			
		else
			
			for q, r in pairs(t_TargetTable) do
				
				if World_OwnsEGroup(r.name, ANY) == true then
					
					UI_CreateMinimapBlip(r.name, 10, BT_CaptureHerePing)
					
				end
				
			end
		end	
	end
end

-- removes hintpoints once a building is taken over, or all buildings destroyed
function Rule_HintPointRemove()
	
	if EGroup_IsEmpty(eg_AllSecondaryBuildings) == true or g_NumberOfHumans <= 1 then
		
		Rule_RemoveMe()
		
	elseif EGroup_IsEmpty(eg_AllSecondaryBuildings) == false and g_NumberOfHumans >= 2 then
		
		for k, v in pairs(t_TargetTable) do
			
			if EGroup_IsEmpty(v.name) or ((World_OwnsEGroup(v.name, ANY) == false) and v.captured == false) then --or math.floor(Timer_GetRemaining("HintpointRemoval")) <= 0 then
				
				if World_OwnsEGroup(v.name, ANY) == false and v.captured == false then
					
					if Player_OwnsEGroup(Game_GetLocalPlayer(), v.name) == true then
					
						PlayInvasionSpeech(Game_GetLocalPlayer(), v.capturedpath)
						
					end
					
				end
				
				
				if v.hintpointID ~= nil then
					HintPoint_Remove(v.hintpointID) -- removes constant hintpoints
				end
				
				v.hintpointID = HintMouseover_Add(v.hinttext, v.name, 10, true ) -- add hintpoints that show up if the player mouses over
				
				v.captured = true
				
			end
			
		end
		
	end
	
end


function Bouc_CpuInit()

--	AI_Enable(g_CreepPlayer, false ) -- disable AI for computer

end



function Bouc_Difficulty()

	t_UnitsToDebuff = {SBP.AXIS.TIGER, SBP.AXIS.PANTHER}
	
end


-------------------------------------------------------------------------

-- MISSION Preset 

-------------------------------------------------------------------------

function Bouc_MissionPreset()

	Rule_CreepSpawnInit()
	Rule_CreepSpawnPreset()
	Rule_Add(Bouc_DisableCoCommander)
	
end

function Bouc_DisableCoCommander()
	UI_BindingSetEnabled("company_commander", false)
	Rule_RemoveMe()
end

-------------------------------------------------------------------------

-- MISSION START 

-------------------------------------------------------------------------

function Bouc_MissionStart()

	Rule_AddOneShot(Invasion_FadeBlack, 1)
	Rule_AddOneShot(Bouc_DelayDefend_HQ, 10)
	Rule_AddInterval(_CountAvg_Track, 30)
	Rule_AddOneShot(Bouc_DisableAxisFuelUI, 1)
	
end

-- disables fuel UI for axis since axis isn't going to use it
function Bouc_DisableAxisFuelUI()

	
	local locPlayer = Game_GetLocalPlayer()
		
	if Player_IsHuman(locPlayer) and Player_GetRaceName(locPlayer) == TRACE_AXIS then
		
		UI_BindingSetEnabled("fuel", false)
		UI_BindingSetEnabled("fuel_rate", false)
		UI_BindingSetEnabled("fuel_img", false)
		
	end
	
end

function Invasion_FadeBlack()

	Game_FadeToBlack(false, 1)
	Rule_AddOneShot(Invasion_EnableMainMenu, 1)

end

function Invasion_EnableMainMenu()

	UI_BindingSetEnabled( "system_menu", true)

end


function Bouc_DelayDefend_HQ()
	
	Objective_Start(OBJ_Defend_HQ)
	
-- the following grabs the number of humans and then sets a flag that designates whether or not to display the score in the single box or dual box.	
	if g_NumberOfHumans == 1 then
		
		UI_SetDisplayIngameScore(true, false)
		g_SinglePlayer = true
		
	else
		
		UI_SetDisplayIngameScore(false, true)
		
	end
	
	-- initializing individual score to 0
	for k, v in pairs(t_PlayerHumanInfo) do
		
		UpdatePlayerScores(v.playerID)
		
	end

	Rule_AddDelayedInterval(Rule_UpdateIndividualScore, 1, 1)
	Rule_AddDelayedInterval(Rule_TrackTotalScore, 2, 1)
	
	-- starts off a timer that is the length of the countdown time
	Objective_StartTimer(OBJ_Defend_HQ, COUNT_DOWN, g_CountdownTime, -1)
	
	Timer_Start("HintpointRemoval", g_CountdownTime)
	
	if g_NumberOfHumans == 1 then
		
		Rule_AddOneShot(Rule_SinglePlayerBuildingHintPoints, 1)
		
	elseif g_NumberOfHumans >= 2 then	
		
		Rule_AddOneShot(Rule_CreateBuildingHintPoints, 10)
		
	end
	
	Rule_AddDelayedInterval(Rule_HintPointRemove, 10, 1)
	
	-- kicks off Creep Spawn after countdown has elapsed
	Rule_AddOneShot(CreepSpawn_Kickoff, g_CountdownTime)
	
	Rule_AddDelayedInterval(Rule_TargetIndexTracker, 1, 1)
	Rule_AddDelayedInterval(Rule_TargetStateTracker, 1, 1)
	Rule_AddDelayedInterval(Rule_HQStateTracker, 1, 1)
	Rule_AddDelayedInterval(Rule_CreepNextAttack, 2, 5) -- used to be every 1 second
	
	Rule_AddDelayedInterval(Creep_VehicleTrack, 2, 1)
	
	Rule_AddDelayedInterval(Rule_PlayerBuildingTracker, 3, 1)
	
	Rule_AddDelayedInterval(Rule_SpecialAbilityAddition, 1, 1)

end



-------------------------------------------------------------------------
-- Objective Name 
-------------------------------------------------------------------------
-- Defend HQ Objective 
-------------------------------------------------------------------------
function Initialize_OBJ_Defend_HQ()

	OBJ_Defend_HQ = {
		
		SetupUI = function() 
			-- mark a point or position
			-- OBJ_Defend_HQ.mapElementID = Objective_AddUIElements(OBJ_Defend_HQ, mkr_marker, true, 000000, true)
		end,
		
		OnStart = function()
			
			-- announce the goal
			-- Util_AutoIntel(t_obj_title.EventStart)
			
			-- win/lose check
			-- Rule_AddInterval(Defend_HQ_WinCheck, 5)
			
			-- start related action
			--Defend_HQ_Kickoff()
			-- EncounterName_Kickoff()
			
		end,
		
		OnComplete = function()
			
			-- tell the player they did good
			
		end,
		
		IsComplete = function()
			return false
		end,
		
		OnFail = function()
			
			-- tell the player they lost
			
		end,
		
		--Title = LOC("Prevent Enemies From Overwhelming Your Defences!"),
		Title = 10000000,
		Description = 10000001,
		TitleEnd = 10000002,
		Type = OT_Primary,
		
	}
	
	-- Register Objective
	Objective_Register(OBJ_Defend_HQ)
	-- Initialize Data
	--Defend_HQ_Init()
	
end


function Rule_CreepSpawnInit()
	
	sg_CreepOverGroup = SGroup_CreateIfNotFound("sg_CreepOverGroup")
	
	
	g_WaveProgression = 1 -- keeps track of progression of waves, starts at 1
	g_SubWave = 1 -- keeps track of subwave progression.  starts at 1
	g_CreepSpawnTimer = 0 -- for the creep spawn timer
	
	-- timer that forces the spawning of the next wave if there's a unit or two left that are idling in the middle of nowhere, 
	-- or if the player is deliberately taking their time to kill them to give themselves more time to set up.
	g_CreepBackupTimer = (90 - (g_NumberOfHumans * 5))
	g_CreepBackupTimerName = "CreepBackupTimer"
	g_CreepBackupTimerStarted = false
	
	g_CreepPriority = 1 -- 1 should be anti-infantry by default, 2 should be anti-tank by default, 3 should be mix of both
	
	fg_LastWave = false -- global flag for when the last wave is sent
	fg_EndFlag = false -- global flag when it's the very end and end stuff has been allocated
	g_CreepSurvived = 0
	g_TotalScore = 0 -- the total score at the end of the game.  you get points for surviving a wave!
	--g_IndividualScore = 0
	g_AbilityCounter = 1 -- counter to determine which ability in the ability list the computer is granting to the player 
	
	-- eventually we will have to have different creeptypes depending on the race of the player...  Thus, if Axis then Allied enemies, etc.
	-- probably will have to have 2 tables containing the tables of different creeptypes, or something like that
	
	g_NebelDialogueCooldown = 0 -- nebelwerfer dialogue cooldown so message isn't repeatedly spammed all the time.  Set to 0 to kick off
	g_MortarDialogueCooldown = 0 -- Mortar dialogue cooldown so message isn't repeatedly spammed all the time.  Set to 0 to kick off
	g_CalliopeDialogueCooldown = 0
--	for i = 1, table.getn(t_PlayerIDInfo) do
	
		if Player_GetRaceName(g_CreepPlayer) == "axis" then
			
			t_CreepType1 = {SBP.AXIS.PIONEER}
			t_CreepType2 = {SBP.AXIS.GRENADE_DISCHARGER}
			t_CreepType3 = {SBP.AXIS.IJA_REGULAR}
			t_CreepType4 = {SBP.AXIS.BRIGHTDIVISION} 
			t_CreepType5 = {SBP.AXIS.SNIPER} -- SBP.AXIS.KNIGHTSCROSS?
			t_CreepType6 = {SBP.AXIS.MOTORCYCLE} 
			t_CreepType7 = {SBP.AXIS.NISSAN}
			t_CreepType8 = {SBP.AXIS.RECRUIT_HO_HA_HALFTRACK} 
			t_CreepType9 = {SBP.AXIS.OSTWIND} 
			t_CreepType10 = {SBP.AXIS.STUG} 
			t_CreepType11 = {SBP.AXIS.PANZER } 
			t_CreepType12 = {SBP.AXIS.PANTHER} 
			t_CreepType13 = {SBP.AXIS.TIGER} 
			t_CreepType14 = {SBP.COHO.INVASION_AXIS_NEBELWERFER}
			t_CreepType15 = {SBP.AXIS.HEAVYMG}
			t_CreepType16 = {SBP.AXIS.MORTAR}
			t_CreepType17 = {SBP.AXIS.KING_TIGER}
			t_VehicleTable = {SBP.AXIS.MOTORCYCLE, SBP.AXIS.PANZER, SBP.AXIS.HALFTRACK, SBP.AXIS.STUG, SBP.AXIS.PANTHER, SBP.AXIS.OSTWIND, SBP.AXIS.NISSAN, SBP.AXIS.TIGER, SBP.COHO.INVASION_AXIS_NEBELWERFER}
			t_InfantryTable = {SBP.AXIS.PIONEER, SBP.AXIS.GRENADE_DISCHARGER, SBP.AXIS.IJA_REGULAR, SBP.AXIS.BRIGHTDIVISION, SBP.AXIS.HEAVYMG, SBP.AXIS.MORTAR}
			t_OppositeVehicleTable = {SBP.COHO.INVASION_ALLIES_NEBELWERFER, SBP.COHO.INVASION_ALLIES_GREYHOUND, SBP.COHO.INVASION_ALLIES_JEEP, SBP.COHO.INVASION_ALLIES_SHERMAN, SBP.COHO.INVASION_ALLIES_PERSHING, SBP.COHO.INVASION_ALLIES_M10, SBP.COHO.INVASION_ALLIES_AT}
			t_OppositeInfantryTable = {SBP.COHO.INVASION_ALLIES_ENGINEER, SBP.COHO.INVASION_ALLIES_RANGERS, SBP.COHO.INVASION_ALLIES_RIFLEMEN, SBP.COHO.INVASION_ALLIES_SNIPER}
			
		elseif Player_GetRaceName(g_CreepPlayer) == "allies" then	
			
			t_CreepType1 = {SBP.ALLIES.ENGINEER}
			t_CreepType2 = {SBP.ALLIES.GUOZDD}
			t_CreepType3 = {SBP.ALLIES.ZHUANGDING}
			t_CreepType4 = {SBP.ALLIES.GUOMEI_TEAM} 
			t_CreepType5 = {SBP.ALLIES.SNIPER}
			t_CreepType6 = {SBP.ALLIES.RECRUIT_LIANLUOGUAN} 
			t_CreepType7 = {SBP.ALLIES.TYPE1}
			t_CreepType8 = {SBP.ALLIES.CROCODILE} 
			t_CreepType9 = {SBP.ALLIES.HALFTRACK} 
			t_CreepType10 = {SBP.ALLIES.PAK_35} 
			t_CreepType11 = {SBP.ALLIES.SHERMAN} 
			t_CreepType12 = {SBP.ALLIES.FT1} 
			t_CreepType13 = {SBP.ALLIES.T26}
			t_CreepType14 = {SBP.COHO.INVASION_ALLIES_NEBELWERFER} 
			t_CreepType15 = {SBP.ALLIES.HEAVYMG}
			t_CreepType16 = {SBP.ALLIES.MORTAR}
			t_CreepType17 = {SBP.ALLIES.CALLIOPE}
			t_VehicleTable = {SBP.ALLIES.RECRUIT_LIANLUOGUAN, SBP.ALLIES.SHERMAN, SBP.ALLIES.PAK_35, SBP.ALLIES.FT1, SBP.ALLIES.T26, SBP.ALLIES.TYPE1, SBP.ALLIES.HALFTRACK, SBP.COHO.INVASION_ALLIES_NEBELWERFER}
			t_InfantryTable = {SBP.ALLIES.ENGINEER, SBP.ALLIES.GUOZDD, SBP.ALLIES.GUOMEI_TEAM, SBP.ALLIES.ZHUANGDING, SBP.ALLIES.HEAVYMG, SBP.ALLIES.MORTAR}
			t_OppositeVehicleTable = {SBP.COHO.INVASION_AXIS_NEBELWERFER, SBP.COHO.INVASION_AXIS_MOTORCYCLE, SBP.COHO.INVASION_AXIS_PUMA, SBP.COHO.INVASION_AXIS_STUG, SBP.COHO.INVASION_AXIS_PANZER, SBP.COHO.INVASION_AXIS_PANTHER, SBP.COHO.INVASION_AXIS_TIGER}
			t_OppositeInfantryTable = {SBP.COHO.INVASION_AXIS_GRENADIERS, SBP.COHO.INVASION_AXIS_HMG, SBP.COHO.INVASION_AXIS_MORTAR, SBP.COHO.INVASION_AXIS_PIONEER, SBP.COHO.INVASION_AXIS_SNIPER, SBP.COHO.INVASION_AXIS_VOLKSGRENADIERS}
			
		end
	--end
	
	local player_receivedaccuracy_factortable = {}
	local enemy_receiveddamage_factortable = {}
	local player_entities = {}
	local enemy_entities = {}
	local strong_enemy_entities = {}
	local strong_enemy_receiveddamage_modifier = 1.0
	
	-- set the scale factor depending on the player's race, and the number of players
	if Player_GetRaceName(g_CreepPlayer) == TRACE_AXIS then			-- (enemy is axis, so player must be allied)
		
		-- player is ALLIED, so these are the scale factors: (allied tunings aren't quite as harsh as the axis ones)
		player_receivedaccuracy_factortable[1] = 0.0 	-- 1 player (higher numbers = weaker players)
		player_receivedaccuracy_factortable[2] = 0.2 	-- 2 player
		player_receivedaccuracy_factortable[3] = 0.3	-- 3 player
		player_receivedaccuracy_factortable[4] = 0.35 	-- 4 player
		
		enemy_receiveddamage_factortable[1] = 0.0		-- 1 player (lower negative numbers = stronger enemies)
		enemy_receiveddamage_factortable[2] = -0.1		-- 2 player
		enemy_receiveddamage_factortable[3] = -0.2		-- 3 player
		enemy_receiveddamage_factortable[4] = -0.27		-- 4 player
		
		strong_enemy_receiveddamage_modifier = 0.8		-- value listed above is multiplied by this for the "strong" units
		
		player_infantry_entities = {											-- a list of all of the INVASION ALLIES ebps that are used by squads available to the player
			"EBPs/races/allies/soldiers/invasion_boys.lua",
			"EBPs/races/allies/soldiers/invasion_boys_crew.lua",
			"EBPs/races/allies/soldiers/invasion_boys_crew2.lua",
			"EBPs/races/allies/soldiers/invasion_engineer.lua",
			"EBPs/races/allies/soldiers/invasion_engineer2.lua",
			"EBPs/races/allies/soldiers/invasion_guo_grenadiar.lua",
			"EBPs/races/allies/soldiers/invasion_guojunzdd.lua",
			"EBPs/races/allies/soldiers/invasion_guojunzdd2.lua",
			"EBPs/races/allies/soldiers/invasion_guojunzdd3.lua",
			"EBPs/races/allies/soldiers/invasion_guojunzdd4.lua",
			"EBPs/races/allies/soldiers/invasion_guojunzdd5.lua",
			"EBPs/races/allies/soldiers/invasion_huajiguan.lua",
			"EBPs/races/allies/soldiers/invasion_huajiguan2.lua",
			"EBPs/races/allies/soldiers/invasion_huajiguan3.lua",
			"EBPs/races/allies/soldiers/invasion_huajiguan4.lua",
			"EBPs/races/allies/soldiers/invasion_machine_gun_crew.lua",
			"EBPs/races/allies/soldiers/invasion_machine_gun_crew2.lua",
			"EBPs/races/allies/soldiers/invasion_mortar_gunner.lua",
			"EBPs/races/allies/soldiers/invasion_mortar_gunner2.lua",
			"EBPs/races/allies/soldiers/invasion_sniper.lua",
			"EBPs/races/allies/soldiers/invasion_zgjunnoh_weapon_crew.lua",
			"EBPs/races/allies/soldiers/invasion_zgjunnoh_weapon_crew2.lua",
		}
		player_vehicle_entities = {
			"EBPs/races/allies/vehicles/jeep_invasion.lua",
			"EBPs/races/allies/vehicles/m1_57mm_towed_at_gun_invasion.lua",
			"EBPs/races/allies/vehicles/m4_sherman_invasion.lua",
			"EBPs/races/allies/vehicles/m8_greyhound_invasion.lua",
			"EBPs/races/allies/vehicles/m10_tank_destroyer_invasion.lua",
			"EBPs/races/allies/vehicles/m26_pershing_invasion.lua",
			"EBPs/races/axis/vehicles/coho_invasion_150mm_nebelwerfer.lua",
		}
		enemy_entities = {														-- a list of all of the AXIS ebps that are used by enemy squads
			"EBPs/races/axis/soldiers/pioneer.lua",
			"EBPs/races/axis/soldiers/grenadier.lua",
			"EBPs/races/axis/soldiers/grenadier_leader.lua",
			"EBPs/races/axis/soldiers/stormtrooper_grenadier.lua",
			"EBPs/races/axis/soldiers/stormtrooper_grenadier_leader.lua",
			"EBPs/races/axis/soldiers/machine_gunner.lua",
			"EBPs/races/axis/soldiers/mortar_gunner",
			"EBPs/races/axis/soldiers/volksgrenadier.lua",
			"EBPs/races/axis/soldiers/volksgrenadier_leader.lua",
			"EBPs/races/axis/vehicles/motorcycle.lua",
			"EBPs/races/axis/vehicles/panzer_iv.lua",
			"EBPs/races/axis/vehicles/sdkfz_251_halftrack.lua",
			"EBPs/races/axis/vehicles/stug_iv.lua",
			"EBPs/races/axis/vehicles/ostwind_flak_panzer.lua",
			"EBPs/races/axis/vehicles/sdkfz234_armoured_car.lua",
			"EBPs/races/axis/vehicles/coho_invasion_150mm_nebelwerfer.lua",
		}
		strong_enemy_entities = {												-- these specific ebps get an extra factor on their modifier
			"EBPs/races/axis/vehicles/panther.lua",
			"EBPs/races/axis/vehicles/tiger.lua",
		}
		
	elseif Player_GetRaceName(g_CreepPlayer) == TRACE_ALLIES then
		
		-- player is AXIS, so these are the scale factors:
		player_receivedaccuracy_factortable[1] = 0.0 	-- 1 player (higher numbers = weaker players)
		player_receivedaccuracy_factortable[2] = 0.4 	-- 2 player
		player_receivedaccuracy_factortable[3] = 0.45	-- 3 player
		player_receivedaccuracy_factortable[4] = 0.5 	-- 4 player
		
		enemy_receiveddamage_factortable[1] = 0.0		-- 1 player (lower numbers = stronger enemies)
		enemy_receiveddamage_factortable[2] = -0.15		-- 2 player
		enemy_receiveddamage_factortable[3] = -0.28		-- 3 player
		enemy_receiveddamage_factortable[4] = -0.35		-- 4 player
		
		strong_enemy_receiveddamage_modifier = 0.8		-- value listed above is multiplied by this for the "strong" units
		
		player_infantry_entities = {											-- a list of all of the INVASION AXIS ebps that are used by squads available to the player
			"EBPs/races/axis/soldiers/grenadier_invasion.lua",		
			"EBPs/races/axis/soldiers/grenadier_leader_invasion",		
			"EBPs/races/axis/soldiers/machine_gunner_invasion.lua",		
			"EBPs/races/axis/soldiers/mortar_gunner_invasion.lua",		
			"EBPs/races/axis/soldiers/pioneer_invasion.lua",		
			"EBPs/races/axis/soldiers/sniper_invasion.lua",		
			"EBPs/races/axis/soldiers/volksgrenadier_invasion.lua",		
			"EBPs/races/axis/soldiers/volksgrenadier_leader_invasion.lua",		
			"EBPs/races/axis/soldiers/weapon_crew.lua",		
		}
		player_vehicle_entities = {
			"EBPs/races/axis/vehicles/coho_invasion_150mm_nebelwerfer.lua",		
			"EBPs/races/axis/vehicles/motorcycle_invasion.lua",		
			"EBPs/races/axis/vehicles/panther_invasion.lua",		
			"EBPs/races/axis/vehicles/panzer_iv_invasion.lua",		
			"EBPs/races/axis/vehicles/sdkfz234_armoured_car_invasion.lua",		
			"EBPs/races/axis/vehicles/stug_iv_invasion.lua",		
			"EBPs/races/axis/vehicles/tiger_invasion.lua",		
			"EBPs/races/axis/vehicles/tiger_ace_invasion.lua",		
		}
		enemy_entities = {														-- a list of all of the ALLIES ebps that are used by enemy squads
			"EBPs/races/allies/soldiers/engineer.lua",
			"EBPs/races/allies/soldiers/infantry_rifleman.lua",
			"EBPs/races/allies/soldiers/infantry_rifleman_sergeant.lua",
			"EBPs/races/allies/soldiers/airborne_infantry.lua",
			"EBPs/races/allies/soldiers/ranger.lua",
			"EBPs/races/allies/soldiers/ranger_leader.lua",
			"EBPs/races/allies/soldiers/machine_gun_crew.lua",
			"EBPs/races/allies/soldiers/mortar_gunner.lua",
			"EBPs/races/allies/soldiers/weapon_crew.lua",		
			"EBPs/races/allies/vehicles/jeep.lua",		
			"EBPs/races/allies/vehicles/m4_sherman.lua",		
			"EBPs/races/allies/vehicles/m1_57mm_towed_at_gun.lua",		
			"EBPs/races/allies/vehicles/m10_tank_destroyer.lua",		
			"EBPs/races/allies/vehicles/m26_pershing.lua",		
			"EBPs/races/allies/vehicles/m8_greyhound.lua",		
			"EBPs/races/allies/vehicles/m3_halftrack.lua",		
			"EBPs/races/axis/vehicles/coho_invasion_150mm_nebelwerfer.lua",		
		}
		strong_enemy_entities = {
			-- currently empty
		}
		
	end
	
	-- pick the relevant factors for the number of players that are playing
	local player_infantry_receivedaccuracy_factor = 1 + player_receivedaccuracy_factortable[g_NumberOfHumans]
	local player_vehicle_receivedaccuracy_factor = 1 + (player_receivedaccuracy_factortable[g_NumberOfHumans] / 2)
	local enemy_receiveddamage_factor = 1 + enemy_receiveddamage_factortable[g_NumberOfHumans]
	local strong_enemy_receiveddamage_factor = 1 + (enemy_receiveddamage_factortable[g_NumberOfHumans] * strong_enemy_receiveddamage_modifier)
	
	-- loop through each human player
	for k, player in pairs(t_PlayerHumanInfo) do
		
		-- now apply the received accuracy modifier to every entity type for this player...
 		for k, ebp in pairs(player_infantry_entities) do
			local blueprint = BP_GetEntityBlueprint(ebp)
 			local modifier1 = Modifier_Create(MAT_EntityType, "modifiers\\received_accuracy_modifier.lua", MUT_Multiplication, false, player_infantry_receivedaccuracy_factor, blueprint)
 			local modifier2 = Modifier_Create(MAT_EntityType, "modifiers\\received_damage_modifier.lua", MUT_Multiplication, false, player_infantry_receivedaccuracy_factor, blueprint)
			Modifier_ApplyToPlayer(modifier1, player.playerID)
			Modifier_ApplyToPlayer(modifier2, player.playerID)
		end
		
 		for k, ebp in pairs(player_vehicle_entities) do
			local blueprint = BP_GetEntityBlueprint(ebp)
 			local modifier1 = Modifier_Create(MAT_EntityType, "modifiers\\received_accuracy_modifier.lua", MUT_Multiplication, false, player_vehicle_receivedaccuracy_factor, blueprint)
 			local modifier2 = Modifier_Create(MAT_EntityType, "modifiers\\received_damage_modifier.lua", MUT_Multiplication, false, player_vehicle_receivedaccuracy_factor, blueprint)
			Modifier_ApplyToPlayer(modifier1, player.playerID)
			Modifier_ApplyToPlayer(modifier2, player.playerID)
		end
		
	end
	
	-- now apply the damage factor to every enemy entity type for the creep player...
	for k, ebp in pairs(enemy_entities) do
		local blueprint = BP_GetEntityBlueprint(ebp)
		local modifier = Modifier_Create(MAT_EntityType, "modifiers\\received_damage_modifier.lua", MUT_Multiplication, false, enemy_receiveddamage_factor, blueprint)
		Modifier_ApplyToPlayer(modifier, g_CreepPlayer)
	end
	for k, ebp in pairs(strong_enemy_entities) do
		local blueprint = BP_GetEntityBlueprint(ebp)
		local modifier = Modifier_Create(MAT_EntityType, "modifiers\\received_damage_modifier.lua", MUT_Multiplication, false, strong_enemy_receiveddamage_factor, blueprint)
		Modifier_ApplyToPlayer(modifier, g_CreepPlayer)
	end
	
	
	
	
	
	g_lastbosspick = 1
	t_BossSpawnSpeech = {soundData.boss.one, soundData.boss.two, soundData.boss.three, soundData.boss.four, soundData.boss.five}
	t_RandomBossSpawn = {}
	t_RandomSpawnLocation = {mkr_CreepSpawn1, mkr_CreepSpawn2}--, mkr_CreepSpawn2, mkr_CreepSpawn3, mkr_CreepSpawn4} -- list of spawn locations
	t_RandomBossSpawnLocation = {mkr_CreepSpawn1, mkr_CreepSpawn2, mkr_CreepSpawn3, mkr_CreepSpawn4, mkr_CreepSpawn5, mkr_CreepSpawn6} -- list of spawn locations
	t_RandomObjectives = {eg_bank, eg_church, eg_manor, eg_garage}--eg_bank, eg_church, eg_manor, eg_store, eg_cafe}
	t_RoleType = {"defender", "heavy", "vehicle", "rocket", "flamer", "building", "sniper", "LMG", "demo", "escort", "repair", "nebel", "HMG", "mortar","vehicleescort","ATGun", "CamoSnipers", "Calliope"}
	-- new types = recoiless rifle, sticky bombs, panzerschrecks on stormtroopers, grenadier, LMG+building,
	

	
	t_InfCardinalDirections = {{dir = "north", path = soundData.enemyapproach.infantry.north },
								{dir = "south", path = soundData.enemyapproach.infantry.south},
								{dir = "east", path = soundData.enemyapproach.infantry.east}, 
								{dir ="west", path = soundData.enemyapproach.infantry.west},
								}
	t_ArmCardinalDirections = {{dir = "north", path = soundData.enemyapproach.armor.north },
								{dir = "south", path = soundData.enemyapproach.armor.south},
								{dir = "east", path = soundData.enemyapproach.armor.east}, 
								{dir ="west", path = soundData.enemyapproach.armor.west},
								}
	
	t_LightArmCardinalDirections = {{dir = "north", path = soundData.enemyapproach.lightarmor.north },
								{dir = "south", path = soundData.enemyapproach.lightarmor.south},
								{dir = "east", path = soundData.enemyapproach.lightarmor.east}, 
								{dir ="west", path = soundData.enemyapproach.lightarmor.west},
								}
	
	t_SpawnLocationsAndGoals = {
	
		{
			spawnlocation = mkr_CreepSpawn1, direction = "west", defaulttarget = t_RandomObjectives[1], -- spawn locations, default target
			rallypoints = {mkr_Spawn1RallyA1, mkr_Spawn1RallyB1, mkr_Spawn1RallyC1}, -- rally points
			paths = {{pathname = "Spawn1RallyAPath1", used = false}, {pathname = "Spawn1RallyBPath1", used = false}}, -- vehicle paths
			--garrisonbuildings = {eg_Spawn1Building1, eg_Spawn1Building2, eg_Spawn1Building3, eg_Spawn1Building4}, -- buildings to hide in
			garrisonbuildings = {eg_Spawn1RallyABuilding1, eg_Spawn1RallyBBuilding1}, -- buildings to hide in
			artillery = {mkr_Spawn1Artillery1,mkr_Spawn1Artillery2},
			nebelpaths = {"Spawn1NebelPath1"},
			crushpath = {"crushpath1"},
			crushactivated = false,
			text = 10000024,
			--smokearea = 
		},
		
		{
			spawnlocation = mkr_CreepSpawn2, direction = "north", defaulttarget = t_RandomObjectives[2], -- spawn locations, default target
			rallypoints = {mkr_Spawn2RallyA1, mkr_Spawn2RallyB1, mkr_Spawn2RallyC1}, -- rally points
			paths = {{pathname = "Spawn2RallyAPath1", used = false}, {pathname = "Spawn2RallyBPath1", used = false}}, -- vehicle paths
			--garrisonbuildings = {eg_Spawn2Building1, eg_Spawn2Building2, eg_Spawn2Building3, eg_Spawn2Building4}, -- buildings to hide in
			garrisonbuildings = {eg_Spawn2RallyABuilding1, eg_Spawn2RallyBBuilding1}, -- buildings to hide in
			artillery = {mkr_Spawn2Artillery1, mkr_Spawn2Artillery2},
			nebelpaths = {"Spawn2NebelPath1"},
			crushpath = {"crushpath2"},
			crushactivated = false,
			text = 10000021,
			--smokearea = 
		},
		
		{
			spawnlocation = mkr_CreepSpawn3, direction = "east", defaulttarget = t_RandomObjectives[3], -- spawn locations, default target
			rallypoints = {mkr_Spawn3RallyA1, mkr_Spawn3RallyB1, mkr_Spawn3RallyC1}, -- rally points
			paths = {{pathname = "Spawn3RallyAPath1", used = false}, {pathname = "Spawn3RallyBPath1", used = false}}, -- vehicle paths
			--garrisonbuildings = {eg_Spawn3Building1, eg_Spawn3Building2, eg_Spawn3Building3, eg_Spawn3Building4}, -- buildings to hide in
			garrisonbuildings = {eg_Spawn3RallyABuilding1, eg_Spawn3RallyBBuilding1}, -- buildings to hide in
			artillery = {mkr_Spawn3Artillery1, mkr_Spawn3Artillery2},
			nebelpaths = {"Spawn3NebelPath1"},
			crushpath = {"crushpath3"},
			crushactivated = false,
			text = 10000022,
			--smokearea = 
		},
		
		{
			spawnlocation = mkr_CreepSpawn4, direction = "west", defaulttarget = t_RandomObjectives[4], -- spawn locations, default target
			rallypoints = {mkr_Spawn4RallyA1, mkr_Spawn4RallyB1, mkr_Spawn4RallyC1}, -- rally points
			paths = {{pathname = "Spawn4RallyAPath1", used = false}, {pathname = "Spawn4RallyBPath1", used = false}}, -- vehicle paths
			--garrisonbuildings = {eg_Spawn4Building1, eg_Spawn4Building2, eg_Spawn4Building3, eg_Spawn4Building4}, -- buildings to hide in
			garrisonbuildings = {eg_Spawn4RallyABuilding1, eg_Spawn4RallyBBuilding1}, -- buildings to hide in
			artillery = {mkr_Spawn4Artillery1, mkr_Spawn4Artillery2},
			nebelpaths = {"Spawn4NebelPath1"},
			crushpath = {"crushpath4"},
			text = 10000024,
			crushactivated = false,
			--smokearea = 
		},
		
		{
			spawnlocation = mkr_CreepSpawn5, direction = "north", defaulttarget = t_RandomObjectives[2], -- spawn locations, default target
			rallypoints = {mkr_Spawn5RallyA1, mkr_Spawn5RallyB1, mkr_Spawn5RallyC1}, -- rally points
			paths = {{pathname = "Spawn5RallyAPath1", used = false}, {pathname = "Spawn5RallyBPath1", used = false}}, -- vehicle paths
			--garrisonbuildings = {eg_Spawn5Building1, eg_Spawn5Building2, eg_Spawn5Building3, eg_Spawn5Building4}, -- buildings to hide in
			garrisonbuildings = {eg_Spawn5RallyABuilding1, eg_Spawn5RallyBBuilding1}, -- buildings to hide in
			artillery = {mkr_Spawn5Artillery1, mkr_Spawn5Artillery2},
			nebelpaths = {"Spawn5NebelPath1"},
			crushpath = {"crushpath5"},
			crushactivated = false,
			text = 10000021,
			--smokearea = 
		},
		
		{
			spawnlocation = mkr_CreepSpawn6, direction = "south", defaulttarget = t_RandomObjectives[3], -- spawn locations, default target
			rallypoints = {mkr_Spawn6RallyA1, mkr_Spawn6RallyB1, mkr_Spawn6RallyC1}, -- rally points
			paths = {{pathname = "Spawn6RallyAPath1", used = false}, {pathname = "Spawn6RallyBPath1", used = false}}, -- vehicle paths
			--garrisonbuildings = {eg_Spawn6Building1, eg_Spawn6Building2, eg_Spawn6Building3, eg_Spawn6Building4}, -- buildings to hide in
			garrisonbuildings = {eg_Spawn6RallyABuilding1, eg_Spawn6RallyBBuilding1}, -- buildings to hide in
			artillery = {mkr_Spawn6Artillery1, mkr_Spawn6Artillery2},
			nebelpaths = {"Spawn6NebelPath1"},
			crushpath = {"crushpath6"},
			crushactivated = false,
			text = 10000023,
			--smokearea = 
		},
		
		
	}

	local l_RandomSpawnSelector = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals))
	g_SpawnIndex = l_RandomSpawnSelector
	g_LastRandomSpawnSelected = l_RandomSpawnSelector
	g_CreepSpawnLocation = t_SpawnLocationsAndGoals[g_SpawnIndex].spawnlocation -- to initialize initial spawn location
	g_CreepSpawnDirection = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].direction -- to initialize spawn direction
	print("spawn point is... "..Marker_GetName(g_CreepSpawnLocation))
	g_CreepObjective = t_SpawnLocationsAndGoals[g_SpawnIndex].defaulttarget -- to initialize initial objective - []used to be l_RandomObjectiveSelector
	g_CurrentTargetNumber = g_SpawnIndex
	g_TargetIndexNum = 1  -- tracks the target that the enemy is going to attack next. this is the index that indicates which EGroup in t_TargetTable gets attacked next
	
	sg_proxSquads = SGroup_CreateIfNotFound("sg_proxSquads")
	sg_tempSGroup = SGroup_CreateIfNotFound("sg_tempSGroup")
	eg_tempEGroup = EGroup_CreateIfNotFound("eg_tempEGroup")
	sg_overallSGroup = SGroup_CreateIfNotFound("sg_overallSGroup")
	eg_overallEGroup = EGroup_CreateIfNotFound("eg_overallEGroup")
	
	
	
	-- variable only used for checking the amount of squads the enemy has at the last wave
	sg_CreepTempSquads = SGroup_CreateIfNotFound("sg_CreepTempSquads")
	
	t_CreepWaveInfo = {
		
		--NOTE THIS IS THE NEBELWERFER SPAWN TYPE-- USE WITH CAUTION
		--{totalNumber = 1, creepType = t_CreepType14, role = t_RoleType[12], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
		
		--wave 1 -- spawnNumber is the number of the Spawned member of the group, baseSpawnTimer is the time in seconds until the next wave
		{	
			
			spawnInfo = {
				
				-- composition 1 introduction 
				{
					
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1 -- g_CurrentTargetNumber
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					
				},
				
				-- composition 2 introduction with variation
				{
					
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					
				},
				
				-- composition 3 introduction with variation
				{
					
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[2], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					
				},
				
				
			},
			
			baseSpawnTimer = 40 - (5 * g_NumberOfHumans), -- time in seconds until next subwave
			waveBonus = 0, -- bonus for wave starting
			resourceBonus = 50 / g_NumberOfHumans, -- bonus for surviving the wave
			path = false, -- string name of path if the wave is told specifically to go down that path
			killCountThreshold = 7 + (1 * g_NumberOfHumans),
			maxGroupNumber = g_NumberOfHumans, -- number of subwaves
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 0, -- countdown timer for next wave with adjustments
			boss = false,
			lastboss = false,
			beforeboss = false,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "infantry",
			bossnumber = false,
		},
		
		--First appearance of Puma
		{	
			
			spawnInfo = {
				{
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					
				},
			},
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 17 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = false,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "lightarmor",
			bossnumber = false,
			
		},
		
		{	
			
			spawnInfo = {
				{ -- generalist
					
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
			
			
				{ -- anti-tank
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[6], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
				},
				
				{ -- anti-personnel
					
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
				},
				
				{ -- vehicle oriented
					
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective},
					{totalNumber = 1, creepType = t_CreepType6, role = t_RoleType[15], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					
				},
				
			},
			
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 1000,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 16 + (2 * g_NumberOfHumans),
			maxGroupNumber = g_NumberOfHumans,
			maxGroups = 2,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = true,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "lightarmor",
			bossnumber = false,
		},
		
		-- boss 1 Light Vehicle only wave
		
		{	
			
			spawnInfo = {
				{-- axis player fights these
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
				
		
				{ -- allied player fights these
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[2], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[2], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[6], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[17], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
			},
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 40 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = true,
			lastboss = false,
			beforeboss = false,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "lightarmor",
			bossnumber = 1,
			
		},
		
		--First appearance of Stug
		{	
			
			spawnInfo = {
				{
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					
				},
			},
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 40 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,-- true
			lastboss = false,
			beforeboss = false,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "lightarmor",
			bossnumber = false,
		},
		
		
		{	
			
			spawnInfo = {
				{ -- heavy infantry/anti-infantry
					
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- LMG+building
					--{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- grenadier
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[10], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					
				},
				
				{
					-- anti-vehicle
					
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[10], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[4], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- recoiless rifle or panzerfaust/shreck
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					
					
				},
				
							
				{ -- flamer
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[2], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- grenadier
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[10], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					
				},
				
				{
					-- generalist
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, 
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[10], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					
				},
				
			},
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 1000,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 76 + (2 * g_NumberOfHumans),
			maxGroupNumber = g_NumberOfHumans,
			maxGroups = 3,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = true,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "lightarmor",
			bossnumber = false,
		},
		
		--Boss 2
		{	
			
			spawnInfo = {
				
				{ -- axis fights these
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[2], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
				
				
				{  -- allied fights these
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[9], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
				
				
			},
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 40 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = true,-- true
			lastboss = false,
			beforeboss = false,
			crusher = false,
			crusheractivated = false,
			paradropenabled = true,
			consistsof = "lightarmor",
			bossnumber = 2,
			
		},
		
		--First appearance of Panzer
		{	
			
			spawnInfo = {
				{
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
			},
			
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 77 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = false,
			crusher = true,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = false,
		},
		
		{	
			
			spawnInfo = {
				{	-- MG based
					
					
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[2], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- grenadier
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- building and LMG
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[10], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType15, role = t_RoleType[13], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					
				},
				
				{
					-- anti-tank
					
					{totalNumber = 1, creepType = t_CreepType15, role = t_RoleType[6], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[4], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- recoilless rifle or faust/shreck
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- shreck
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					
				},
				
				{
					-- vehicle centric
					
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --grenadier
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					
					
				},
				
				{
					-- anti-personnel - flamer
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- grenadier
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					
				},
				
			},
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 1000,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 121 + (2 * g_NumberOfHumans),
			maxGroupNumber = g_NumberOfHumans,
			maxGroups = 3,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = true,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = false,
		},
		
		-- boss 3
		{	
			
			spawnInfo = { -- axis fights these
				{
				
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[2], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType17, role = t_RoleType[18], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType17, role = t_RoleType[18], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
				
				},
				
				{-- allied fights these
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[9], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType9, role = t_RoleType[2], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType9, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType9, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
				
			},
			
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 77 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = true,
			lastboss = false,
			beforeboss = false,
			crusher = true,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = 3,
			
		},
		
		--First appearance of Nebelwerfer
		{	
			
			spawnInfo = {
				{
					
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType14, role = t_RoleType[12], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[10], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[10], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --stormtroopers
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[1], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType15, role = t_RoleType[13], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					
				},
			},
			
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 128 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = false,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = false,
			
		},
		
		
		{	
			
			spawnInfo = {
				{	-- general
					
					--{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					--{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[15], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[10], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- stormtroopers
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
				},
			
			
				
				{	--anti-tank
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --rocket
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --LMG in building
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- recoiless rifles/shreck/faust
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- stickybomb/faust
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					
				},
				
				{ -- vehicle centric
					
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- LMG in building
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[15], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType15, role = t_RoleType[13], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --stormtrooper
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
				
				
				},
				
					{ -- vehicle centric
					
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- LMG in building
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[15], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[2], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --stormtrooper
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType15, role = t_RoleType[13], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
				
				
				},
				
				
				{ -- long range bombardment
					
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType14, role = t_RoleType[12], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType15, role = t_RoleType[13], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					
					
				
				
				},
				
				
			},
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 1500,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 174 + (2 * g_NumberOfHumans),
			maxGroupNumber = g_NumberOfHumans,
			maxGroups = 3,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = true,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = false,
		},
		
		--Boss 4
		{	
			
			spawnInfo = {
				{ -- axis fights these
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1  creeptype 11
					--{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1 creeptype 11
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					--{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[15], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, -- recoiless rifles/shreck/faust
					--{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[8], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --rocket
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[9], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
				},
				
				{ -- allies fights these
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					--{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					--{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[8], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[9], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
			},
			
			
			baseSpawnTimer = 45 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 129 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = true,
			lastboss = false,
			beforeboss = false,
			crusher = true,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = 4,
			
		},
	

		--First appearance of Heaviest Tank
		{	
			
			spawnInfo = {
				{
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
				},
			},
			
			
			baseSpawnTimer = 50 - (4 * g_NumberOfHumans),
			waveBonus = 300,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 175 + (2 * g_NumberOfHumans),
			maxGroupNumber = 1,
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = false,
			crusher = true,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = false,
		},
		
		{	
			
			spawnInfo = {
				{	-- generalist
					--{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[1], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Pioneers
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Grenadiers
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Tiger
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Tiger
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Grenadiers
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Grenadiers
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Sniper
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Grenadiers
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[10], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Stormtroopers
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Pioneers
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Flame Halftrack
					--{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Panzer
					
				},
			
			
				{ -- anti-personnel
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Grenades
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- 
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Tiger
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Tiger
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- 
					{totalNumber = 1, creepType = t_CreepType5, role = t_RoleType[7], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- 
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- 
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- 
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[10], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Volksgrenadiers
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Pioneers
					{totalNumber = 1, creepType = t_CreepType8, role = t_RoleType[5], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Flame Halftrack
					{totalNumber = 1, creepType = t_CreepType15, role = t_RoleType[13], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
				},
				
				{	--anti-tank
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --rocket
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --tiger
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --panther
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- recoiless rifles/shreck/faust
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- recoiless rifles/shreck/faust
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType10, role = t_RoleType[16], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- stickybomb/faust
					{totalNumber = 1, creepType = t_CreepType2, role = t_RoleType[10], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					
				},
				
				{	--tank-centric
					
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- LMG + building
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Tiger
					{totalNumber = 1, creepType = t_CreepType11, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Panzer				
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Grenadiers
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[8], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective},
					{totalNumber = 1, creepType = t_CreepType14, role = t_RoleType[12], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, -- Nebel
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, -- Panther
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --repairs
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --repairs
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
				
				},
				
				{ -- Long Range
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[6], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType14, role = t_RoleType[12], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --4
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[9], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --3
					{totalNumber = 1, creepType = t_CreepType7, role = t_RoleType[15], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, 
					{totalNumber = 1, creepType = t_CreepType15, role = t_RoleType[13], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[1], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					{totalNumber = 1, creepType = t_CreepType16, role = t_RoleType[14], location = t_RandomSpawnLocation[2], settarget = g_CreepObjective}, --8
					
				
				},
				
				
			},
			
			baseSpawnTimer = 90 - (4 * g_NumberOfHumans),
			waveBonus = 1500,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 221 + (2 * g_NumberOfHumans),
			maxGroupNumber = g_NumberOfHumans,
			maxGroups = 3,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = false,
			beforeboss = true,
			crusher = false,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = false,
		},
		
		
		--Boss 5 (Final Boss)
		{	
			
			spawnInfo = {
				{
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[4], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, -- recoiless rifles/shreck/faust
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --rocket
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1 flamer
				},
				{
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[4], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, -- recoiless rifles/shreck/faust
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --rocket
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1 flamer
				},
				{
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[4], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, -- recoiless rifles/shreck/faust
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --rocket
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1 flamer
				},
				{
					{totalNumber = 1, creepType = t_CreepType13, role = t_RoleType[3], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType12, role = t_RoleType[15], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType4, role = t_RoleType[4], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, -- recoiless rifles/shreck/faust
					{totalNumber = 1, creepType = t_CreepType3, role = t_RoleType[4], location = t_RandomBossSpawnLocation[1], settarget = g_CreepObjective}, --rocket
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[11], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1
					{totalNumber = 1, creepType = t_CreepType1, role = t_RoleType[5], location = t_RandomBossSpawnLocation[2], settarget = g_CreepObjective}, --1 flamer
				},
				
			},
			
			
			baseSpawnTimer = 30 - (4 * g_NumberOfHumans),
			waveBonus = 200,
			resourceBonus = 50 / g_NumberOfHumans,
			path = false,
			killCountThreshold = 129 + (2 * g_NumberOfHumans),
			maxGroupNumber = g_NumberOfHumans + 1, 
			maxGroups = 1,
			timeToNextWave = g_CreepBackupTimer - 10,
			boss = false,
			lastboss = true,
			beforeboss = false,
			crusher = true,
			crusheractivated = false,
			paradropenabled = false,
			consistsof = "armor",
			bossnumber = 5,
			
		},
		
		
		
	}
	
	-- adds redundant information that will probably not be changed inside t_CreepWaveInfo
	for k, this in pairs(t_CreepWaveInfo) do  
		
		for z = 1, table.getn(this.spawnInfo) do
		
			for a, b in pairs(this.spawnInfo[z]) do
			
				
				
				b.spawnNumber = 1
				b.creepMemberName = SGroup_CreateTable("sg_CreepMemberWave_Wave"..k.."_Member_%d_Sub"..a, b.totalNumber)
				b.subGroupName = SGroup_CreateIfNotFound("sg_SubWaveOvergroup_Wave"..k.."_Sub"..z.."_Squad"..a)
				b.vehicleSubGroupName = SGroup_CreateIfNotFound("sg_SubWaveVehicle_Wave"..k.."_Sub"..a.."_Vehicle"..z)
			end
		
			this.spawnInfo[z].overGroupName = SGroup_CreateIfNotFound("sg_Wave"..k.."_Overgroup"..z)
			
		end
		--this.activation = {} -- to store if a unit has its autotargetting on or off.  default state is "false", see below
		--this.survived = {} -- to store if a unit has made it to other side of the map.  default state is "false", see below
		--this.spawnPosition = g_SpawnPosition1
		this.tmrSpawn = "CREEP SPAWN TIMER"..k
		this.spawnDestination = g_SpawnDestination
		this.spawnTime = 0 -- variable for the game time at which this unit was spawned
		this.removalTime = 0 -- variable for the game time at which this unit was removed (destroyed or otherwise)
		this.totalTime = 0 -- variable for how long the squad survived
		this.targetTable = t_TargetTable
		this.compositionType = {} -- tracks the types available for the subwave.  As types are used, the composition is removed from this list.
		
	end
	
	-- adds composition type that we can remove later.  (i.e. say the composition table has 3 entries, and entry 2 has been used, then the 2 will be removed, making it {1, 3}.
	-- Thus, when a random choice is made, the previous choice is never made again because only choices 1 and 3 remain.
	for k, this in pairs(t_CreepWaveInfo) do
	
		for z = 1, table.getn(this.spawnInfo) do
		
			table.insert(this.compositionType, z)
		end
		
	end
	
	
	for k, this in pairs(t_CreepWaveInfo) do
	
--~ 		for i = 1, this.totalNumber do 
--~ 			table.insert(this.activation, i, false)
--~ 			table.insert(this.survived, i, false)
--~ 		end
	
	end

	
	
	g_RandomCompositionInside = 1
	
	--table.getn(t_CreepWaveInfo[g_WaveProgression].spawnInfo))
	
--	local l_RandomComposition = World_GetRand(1, table.getn(t_CreepWaveInfo[g_WaveProgression].spawnInfo))
	
	local l_RandomComposition = World_GetRand(1, table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType))
	local l_RandomCompositionInside = t_CreepWaveInfo[g_WaveProgression].compositionType[l_RandomComposition]
	g_RandomCompositionInside = l_RandomCompositionInside
	g_LastRandomCompositionTableNumber = l_RandomComposition
	
	g_KillCount = 0
	g_CreepGroupsSpawned = 0
	g_CreepWaveCount = table.getn(t_CreepWaveInfo) -- counts how many waves of creeps there are supposed to be
	g_CreepSurvivedCounter = 30
	
	g_LastBuildingDestroyed = false
	g_ProductionDestroyed = false
	g_WaveBonusPenalty = 0 -- contains the numerical value of the penalty to the Wave Bonus should certain buildings get destroyed
	
	
	-- initializes text to be displayed at beginning
	t_begintext = {
		
		{g_Actor, 10000020}, -- Beginning Text
		
	}
	
	t_upgradetext = {
		{g_Actor, 10000025}, -- Beginning Text
	
	}
	
	-- initializes text that will be used to announce whenever a wave is incoming
	t_wavetext = {
		
		--{g_Actor, LOC("Difficulty Level "..g_WaveProgression.." incoming!!" )}, -- Incoming wave text
		{g_Actor, 10000026}, -- Incoming wave text
	}
	
	-- this table will be used to keep track of units that are spawned and their spawn time and death time, for the purposes of calculating multipliers for rewards
	-- it will be dynamically updated so that only units that are alive will be in this table
	t_SpawnedUnitInfo = {}
	
	-- used to store the seperate "squads" of units - will be dynamically updated so that only units that are alive will be in this table
	t_SpawnedSquadInfo = {}
	
	-- used to store overgroup info
	t_OverGroupInfo = {}
	
	-- used to store vehicle info
	t_VehicleInfo = {}
	
	
	-- makes the building non-garrisonable by players or AI
	for q = 1, table.getn(t_TargetTable) do

		--EGroup_SetAvgHealth(t_TargetTable[q].name, 0.5)
		--Modify_ReceivedDamage(t_TargetTable[q].name, 50)
		
		--Modify_DisableHold( t_TargetTable[q].name, true)
		
	end	
	
	
	g_GeneralThreatID = ThreatArrow_CreateGroup()
	g_GeneralThreatLocation = mkr_CreepSpawn1
	
end


function Rule_CreepSpawnPreset()

--	Util_AutoIntel(t_begintext)
	Rule_AddDelayedIntervalEx(Rule_CreepSpawnInitPingLoop, 1, 1, 60)

	
end


function Rule_CreepSpawnInitPingLoop()

	Spawn_Ping(g_CreepSpawnLocation)


end


function CreepSpawn_Kickoff()

	Objective_StopTimer(OBJ_Defend_HQ)
	Objective_UpdateText(OBJ_Defend_HQ, 10000001, 10000001, true) -- "Defend your HQs against waves of enemies!"
	
	Rule_AddDelayedIntervalEx(Rule_CreepDropArtillery, 1, 1, 1)
	
	Rule_AddDelayedInterval(Rule_CreepWinCheck, 5, 1)
--	Util_AutoIntel(t_wavetext) -- displays the warning text about the first wave
	
	g_CreepSpawnDirection = t_SpawnLocationsAndGoals[g_LastRandomSpawnSelected].direction -- to initialize spawn direction
	
	if g_WaveProgression > 0 then
		
		local l_CreepProgression = t_CreepWaveInfo[g_WaveProgression]
		
		PlayInvasionTypeDetermine(l_CreepProgression.consistsof)
		
	end
	
	--line for wave here
	Rule_AddOneShot(DisplayCurrentWave, 5)
	
	Rule_AddInterval(Rule_CreepBackupTimer, 1)
	Rule_AddOneShot(Rule_TurnOffObjectiveText, 20)
	
end

function Rule_TurnOffObjectiveText()
	
	Objective_Show(OBJ_Defend_HQ, false)

end

-- application of Creep Upgrades
function Rule_CreepUpgrades(progression)

	print("FEW: Disabled Rule_CreepUpgrades");
	do return end;

	if progression.role == "rocket" or progression.role == "demo" then
		
		if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.AXIS.GRENADIER, ANY) then
			
			print("instant upgrade for panzerschreck")
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.AXIS.STORM_PANZERSCHRECK, 1)
			SGroup_AddSlotItemToDropOnDeath(progression.creepMemberName[progression.spawnNumber], SLOT_ITEM.PANZERSCHRECK, 0.05, true)
			
		elseif SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.RANGER, ANY) then
			print("instant upgrade for bazookas")
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.ALLIES.BAZOOKA_SP_M13, 1)
			SGroup_AddSlotItemToDropOnDeath(progression.creepMemberName[progression.spawnNumber], SLOT_ITEM.BAZOOKA, 0.1, true)
			
		elseif SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.PARATROOPER, ANY) then
			print("instant upgrade for recoilless rifle")
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.ALLIES.PARATROOPER_AT, 1)
			--SGroup_AddSlotItemToDropOnDeath(progression.creepMemberName[progression.spawnNumber], SLOT_ITEM.BAZOOKA, 0.1, true)
			
		elseif SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.AXIS.STORMTROOPER, ANY) then
			print("instant upgrade for recoilless rifle")
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.AXIS.STORM_PANZERSCHRECK, 1)
			SGroup_AddSlotItemToDropOnDeath(progression.creepMemberName[progression.spawnNumber], SLOT_ITEM.PANZERSCHRECK, 0.05, true)
			
		end
		
	elseif progression.role == "LMG" then
		
		if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.AXIS.GRENADIER, ANY) then
			print("instant upgrade for LMG (axis)")
			local squadname = SGroup_GetSpawnedSquadAt(progression.creepMemberName[progression.spawnNumber], 1)
			Squad_GiveSlotItem(squadname, SLOT_ITEM.LMG_42)
			SGroup_AddSlotItemToDropOnDeath(progression.creepMemberName[progression.spawnNumber], SLOT_ITEM.LMG_42, 0.1, true)
			
		elseif SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.RANGER, ANY) then
			print("instant upgrade for LMG (allies)")

			-- coho thompson actually refers to the default unchanged thompson upgrade in luaconst
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.COHO.PUSH.CREEP_THOMPSON)
			
		end
	
	elseif progression.role == "flamer" then
	
		if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.AXIS.PIONEER, ANY) then
			print("instant upgrade for flamer (axis)")
			
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.AXIS.PIONEER_FLAMETHROWER, 1)
			
		elseif SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.ENGINEER, ANY) then
			print("instant upgrade for flamer (allies)")
			
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.ALLIES.ENGINEER_FLAMETHROWER, 1)
			
		end
		
	elseif progression.role == "Calliope" then	
	
		if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.CALLIOPE, ANY) then
	
			print("instant upgrade for weapon range and sight radius of calliope")
			Modify_SightRadius(progression.creepMemberName[progression.spawnNumber], 2)
			Modify_WeaponRange(progression.creepMemberName[progression.spawnNumber], "hardpoint_01", 2)
	
		end
	end
	
	if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.HALFTRACK, ANY) then
		print("halftrack upgrade")
		Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.ALLIES.HALFTRACK_QUAD, 1)
		
	end
	
	
	if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.GREYHOUND, ANY) then
		print("greyhound upgrade")
		Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.ALLIES.GREYHOUND_MG, 1)
		
	end
	
	if g_WaveProgression >= 3 and progression.role == "vehicle" then
	
		if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.GREYHOUND, ANY) then
			print("greyhound upgrade")
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.ALLIES.GREYHOUND_ARMOR, 1)
			
		end
		
		if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.AXIS.PUMA, ANY) then
			print("puma upgrade")
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.COHO.INVASION.PUMA_50MM, 1)
			
		end
		
		if 	SGroup_ContainsBlueprints(progression.creepMemberName[progression.spawnNumber], SBP.ALLIES.SHERMAN, ANY) then
			print("sherman upgrade")
			Cmd_InstantUpgrade(progression.creepMemberName[progression.spawnNumber], UPG.ALLIES.SHERMAN_MG, 1)
			
		end
		
	end

end

function Rule_CreepSpawnCreation()

		
		local l_CreepProgression = t_CreepWaveInfo[g_WaveProgression]
		
		--local l_SubWaveProgression = l_CreepProgression.spawnInfo[g_RandomCompositionInside][g_SubWave]
		
		
		if l_CreepProgression.boss == true then
				
			if Player_GetRaceName(g_CreepPlayer) == TRACE_ALLIES then
			
				g_RandomCompositionInside = 1
				
				--if l_CreepProgression.paradropenabled == true then
				--
				--	l_CreepProgression.paradropenabled = false
				--	
				--	Rule_AddOneShot(Rule_ParaDropInit, 15)
				--	
				--end
				
			elseif Player_GetRaceName(g_CreepPlayer) == TRACE_AXIS then
				
				g_RandomCompositionInside = 2
				
			end
			
			
		end
		
		
		
		local l_SubWaveProgression = l_CreepProgression.spawnInfo[g_RandomCompositionInside]
		
		-- if the current subwave is less than or at the total number of subwaves possible for the specific wave (defined in the local variable l_CreepProgression)...

		if g_SubWave <= table.getn(l_CreepProgression.spawnInfo[g_RandomCompositionInside]) then -- table.getn(l_CreepProgression.spawnInfo)
		--if g_SubWave <= table.getn(l_CreepProgression.spawnInfo) then -- table.getn(l_CreepProgression.spawnInfo)
		
			-- if the Spawn number is smaller or equal to than the total number of members wanted for this wave then create more	
			if l_SubWaveProgression[g_SubWave].spawnNumber <= l_SubWaveProgression[g_SubWave].totalNumber and SGroup_IsEmpty(l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]) 
				then --and SGroup_IsEmpty(l_SubWaveProgression.overGroupName) == true then
		
				-- define local variables
				--local l_RandomSpawn = World_GetRand(1, table.getn(t_RandomSpawnLocation))
				local l_IsVehicle = false
				--local l_spawnblueprint = l_SubWaveProgression[g_SubWave].creepType[World_GetRand(1, table.getn(t_CreepType1))]
				local l_spawnblueprint = l_SubWaveProgression[g_SubWave].creepType[1]
				local l_targetnumber = l_SubWaveProgression[g_SubWave].targetnumber

				-- spawn squads according to the information listed in the subwave data tables
				
				if l_CreepProgression.boss == true or l_CreepProgression.lastboss == true then
					

					
					local bossspawn = t_RandomBossSpawn[g_lastbosspick].spawnlocation
					
					Util_CreateSquads(g_CreepPlayer, l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber], 
					l_spawnblueprint, bossspawn, nil, 1)-- l_CreepProgression.spawnDestination   Util_GetRandomPosition(t_RandomSpawnLocation[l_RandomSpawn]) l_SubWaveProgression[g_SubWave].location

					if g_lastbosspick < table.getn(t_RandomBossSpawn) then
						
						g_lastbosspick = g_lastbosspick + 1
						
					else
						
						g_lastbosspick = 1
						
					end
					
				else
					Util_CreateSquads(g_CreepPlayer, l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber], 
					l_spawnblueprint, g_CreepSpawnLocation, nil, 1)-- l_CreepProgression.spawnDestination   Util_GetRandomPosition(t_RandomSpawnLocation[l_RandomSpawn]) l_SubWaveProgression[g_SubWave].location
				
				end
					
				l_SubWaveProgression[g_SubWave].settarget = t_SpawnLocationsAndGoals[g_SpawnIndex].defaulttarget			
				
				
				Rule_CreepUpgrades(l_SubWaveProgression[g_SubWave])
				
				
				Spawn_Ping(l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber])
				
				
				--l_CreepProgression.spawnTime = World_GetGameTime() -- records the time at which this unit was spawned
				
				-- adds to the Creep overgroup for that wave
				SGroup_AddGroup(sg_CreepOverGroup,  l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]) 
				SGroup_AddGroup(l_SubWaveProgression[g_SubWave].subGroupName,  l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]) 
				SGroup_AddGroup(l_SubWaveProgression.overGroupName,  l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]) 
				
	
				if EGroup_IsEmpty(l_SubWaveProgression[g_SubWave].settarget) == false then

					--local l_randompos = Util_GetRandomPosition(EGroup_GetPosition(g_CreepObjective), 40)
					--Cmd_AttackMove(l_SubWaveProgression[g_SubWave].subGroupName, EGroup_GetPosition(l_SubWaveProgression[g_SubWave].settarget), false, nil, 40)
					
					local l_randommarkernumber = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals[g_SpawnIndex].rallypoints))
					Cmd_AttackMove(l_SubWaveProgression[g_SubWave].subGroupName, t_SpawnLocationsAndGoals[g_SpawnIndex].rallypoints[l_randommarkernumber], false, nil, 20)
					
				else
					--print("huh?")
					local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
					
					l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)

					if SGroup_IsEmpty(l_humanConcentration) == false then
					
						Cmd_AttackMove(l_SubWaveProgression[g_SubWave].subGroupName, l_humanConcentration, nil, nil, 40)
					
					else
					
						local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
						
						
						l_entityConcentration = Rule_GetPlayerEntityConcentration(l_entityConcentration)
						
						if EGroup_IsEmpty(l_entityConcentration) == false then
							
							Cmd_AttackMove(l_SubWaveProgression[g_SubWave].subGroupName, l_entityConcentration, nil, nil, 40)
							
						end
						
					end
					
				end
				
				local sgAtkCreep = l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]
				
				-- if squad made is vehicle (determined by comparing the squad's blueprints against a table of the vehicles used by its faction in this scenario) then
				if SGroup_ContainsBlueprints(sgAtkCreep, t_VehicleTable, false) then			
					
					l_IsVehicle = true
					
					SGroup_AddGroup(l_SubWaveProgression[g_SubWave].vehicleSubGroupName,  sgAtkCreep) 
					
--~ 					Modify_ReceivedDamage(sgAtkCreep, NumHumanMod(g_NumberOfHumans, sgAtkCreep, l_IsVehicle))
					
				elseif SGroup_ContainsBlueprints(sgAtkCreep, t_InfantryTable, false) then		
					
					l_IsVehicle = false
					
--~ 					Modify_ReceivedDamage(sgAtkCreep, NumHumanMod(g_NumberOfHumans, sgAtkCreep, l_IsVehicle))
					
				end
				
				
				if l_IsVehicle == true then
					
					-- if the vehicle in question is a nebelwerfer, make it move down this path
					if l_SubWaveProgression[g_SubWave].role == "nebel" then
					
						Cmd_SquadPath(sgAtkCreep, t_SpawnLocationsAndGoals[g_SpawnIndex].nebelpaths[1], true, false, true, 0)		
					
					else
						
						-- checks to see if the crush path has been activated for that spawn already.  if so then vehicles can now go down that route.
						if l_CreepProgression.crusher == true and l_CreepProgression.crusheractivated == false then
						
							Cmd_SquadPath(sgAtkCreep, t_SpawnLocationsAndGoals[g_SpawnIndex].crushpath[1], true, false, true, 0)			
							
							l_CreepProgression.crusheractivated = true -- sets the flag that says "Look, there's another path we can use!"
							
							-- adds this path to list of paths that can used by vehicles for that spawn area
							table.insert(t_SpawnLocationsAndGoals[g_SpawnIndex].paths, {pathname = t_SpawnLocationsAndGoals[g_SpawnIndex].crushpath[1], used = false})
						
						else
					
							--chooses a random path to take
							local l_randompath = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals[g_SpawnIndex].paths))
							
							Cmd_SquadPath(sgAtkCreep, t_SpawnLocationsAndGoals[g_SpawnIndex].paths[l_randompath].pathname, true, false, true, 0)		
							
							
						end
							
						
					end	
						
					-- stores information about the current vehicle into t_TempVehicleInfo
					t_TempVehicleInfo = {name = sgAtkCreep}
					table.insert(t_VehicleInfo, t_TempVehicleInfo)
				
				end
				
				
				-- adds what happens when unit dies
				Rule_AddSGroupEvent(Creep_KillReward, l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber], GE_SquadKilled)
				
				-- places the spawned unit's info into a table
				t_TempUnitInfo = {name = l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber], spawntime = World_GetGameTime(), vehicle = l_IsVehicle}
				table.insert(t_SpawnedUnitInfo, t_TempUnitInfo)
				
				-- if the spawn number of the subwave is less than the total number possible of subwaves in the current wave, then iterate the index
				if l_SubWaveProgression[g_SubWave].spawnNumber < l_SubWaveProgression[g_SubWave].totalNumber then
				
					l_SubWaveProgression[g_SubWave].spawnNumber = l_SubWaveProgression[g_SubWave].spawnNumber + 1
					
				
				-- otherwise, reset to one, and move on by iterating the subwave
				elseif l_SubWaveProgression[g_SubWave].spawnNumber >= l_SubWaveProgression[g_SubWave].totalNumber then 
					

					l_SubWaveProgression[g_SubWave].spawnNumber = 1
					
					
					l_blankname = SGroup_CreateIfNotFound(SGroup_GetName(l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]).."blank")

					
					if table.getn(t_VehicleInfo) > 0 then
					
						t_TempSquadInfo = {name = l_SubWaveProgression[g_SubWave].subGroupName, target = l_SubWaveProgression[g_SubWave].settarget, 
							defaulttarget = l_SubWaveProgression[g_SubWave].settarget, role = l_SubWaveProgression[g_SubWave].role, 
							spawnindex = g_SpawnIndex, attacker = l_blankname, vehicletoescort = t_VehicleInfo[World_GetRand(1, table.getn(t_VehicleInfo))].name,
							overgroupname = l_SubWaveProgression.overGroupName, combatPlan = nil}
						
					else
					
						t_TempSquadInfo = {name = l_SubWaveProgression[g_SubWave].subGroupName, target = l_SubWaveProgression[g_SubWave].settarget, 
							defaulttarget = l_SubWaveProgression[g_SubWave].settarget, role = l_SubWaveProgression[g_SubWave].role, 
							spawnindex = g_SpawnIndex, attacker = l_blankname, vehicletoescort = l_SubWaveProgression[g_SubWave].vehicleSubGroupName,
							overgroupname = l_SubWaveProgression.overGroupName, combatPlan = nil}
						
					
					end
					
					table.insert(t_SpawnedSquadInfo, t_TempSquadInfo)
						
					
					--t_TempOverGroupInfo = {name = l_SubWaveProgression[g_SubWave].subGroupName}
					--table.insert(t_OverGroupInfo, t_TempOverGroupInfo)
				

					
					g_SubWave = g_SubWave + 1
					
				end
				
			end
		
		-- if subwave number is greater than possible subwaves in current wave, then reset to 1 and check for wave progression
--~ 		elseif ((g_SubWave > table.getn(l_CreepProgression.spawnInfo[g_RandomCompositionInside])) and 
--~ 		((l_CreepProgression.boss == false) or (l_CreepProgression.boss == true and 
--~ 		SGroup_IsEmpty(l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]) == true))) or
--~ 		(l_CreepProgression.beforeboss == true and SGroup_IsEmpty(sg_CreepOverGroup)) then 
--~ 			
		elseif g_SubWave > table.getn(l_CreepProgression.spawnInfo[g_RandomCompositionInside]) then
			
			t_RandomBossSpawn = {} -- clears boss spawn locations
			
			print("last boss spawn cleared?")
			g_lastbosspick = 1 -- resets lastbosspick
			
		-- randomize spawn only if wave progression is > 1
			if g_WaveProgression > 1 then
			
				local l_RandomSpawnSelector = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals))
				
				if l_RandomSpawnSelector == g_LastRandomSpawnSelected then
						
					if l_RandomSpawnSelector >= table.getn(t_SpawnLocationsAndGoals) then
					
						l_RandomSpawnSelector = 1
						
					elseif l_RandomSpawnSelector == 1 and (table.getn(t_SpawnLocationsAndGoals) > 1) then
					
						l_RandomSpawnSelector = l_RandomSpawnSelector + 1
					
					else
						if (l_RandomSpawnSelector + 1) <= table.getn(t_SpawnLocationsAndGoals) then
						
							l_RandomSpawnSelector = l_RandomSpawnSelector + 1
							
						elseif (l_RandomSpawnSelector - 1 ) > 0 then
					
							l_RandomSpawnSelector = l_RandomSpawnSelector - 1
							
						end
					end
					
				end
					
				
				
				g_SpawnIndex = l_RandomSpawnSelector
				g_LastRandomSpawnSelected = l_RandomSpawnSelector
				print("randomized spawn?")
				print("Last random spawn defined")
				g_CreepSpawnLocation = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].spawnlocation -- to initialize initial spawn location
				g_CreepSpawnDirection = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].direction -- to initialize spawn direction
			end
			t_TempOGInfo = {name = l_SubWaveProgression.overGroupName}
			
			--table.insert(t_OverGroupInfo, t_TempOGInfo)
			
			
			g_CreepGroupsSpawned = g_CreepGroupsSpawned + 1
			print("creepgroup spawned "..g_CreepGroupsSpawned)		
			
			g_SubWave = 1
			
			Rule_RemoveMe()
			
			
			if g_WaveProgression < g_CreepWaveCount then
				
				Rule_AddDelayedInterval(Rule_CreepSpawnTimer, 1, 1) -- starts timer check
				Timer_Start(l_CreepProgression.tmrSpawn, l_CreepProgression.baseSpawnTimer) -- starts timer with next wave
				
			elseif g_WaveProgression == g_CreepWaveCount then
				
				-- sets the global flag for LastWave to be true
				fg_LastWave = true
				
				Rule_AddDelayedInterval(Rule_CreepSpawnTimer, 1, 1) -- starts timer check
				Timer_Start(l_CreepProgression.tmrSpawn, l_CreepProgression.baseSpawnTimer) -- starts timer with next wave
				
				
			end

		end


end

-- modifier to make it so that creep are more durable depending on number of players, done this way so we can specifically
-- tune values depending on number of players, or any other kind of factor. 
function NumHumanMod(humanNum, sgroup, vehicleBool)

	local diffRecDamageMod = 0.0
	local vehRecDamageMod = 0.0
	
	-- if the unit that just got spawned is a vehicle and is one of the special vehicles that need a debuff then make the recieve damage mod an actual number
	if vehicleBool == true and SGroup_ContainsBlueprints(sgroup, t_UnitsToDebuff, ANY) then
		
		vehRecDamageMod = 0.2
		
	end
	
	-- applies modifiers depending on player
	if g_NumberOfHumans == 1 then
		
		return (1 - ((0.021 * g_WaveProgression)/2) - diffRecDamageMod + vehRecDamageMod)
		
	else
		
		if g_NumberOfHumans == 2 then
			
			diffRecDamageMod = 0.10
			
		elseif g_NumberOfHumans == 3 then
			
			diffRecDamageMod = 0.15
			
		elseif g_NumberOfHumans == 4 then
			
			diffRecDamageMod = 0.20
			
		end

		return (1 - ((0.042 * g_WaveProgression)/2) - diffRecDamageMod + vehRecDamageMod)

	end
	
end


---------------------=====================
--PARADROP STUFF

function Rule_ParaDropInit()


	sg_Para = SGroup_CreateTable("sg_Para%d", 10)
	sg_ParaOverGroup = SGroup_CreateIfNotFound("sg_ParaOverGroup")
	g_ParaIndex = 1
	
	t_ParaDrop = {
					{name = sg_Para[1], blueprint = SBP.ALLIES.PARATROOPER, timer = "Para1", timeramount = 5, ordersgiven = false, spawned = false},
					{name = sg_Para[2], blueprint = SBP.ALLIES.PARATROOPER, timer = "Para2", timeramount = 5, ordersgiven = false, spawned = false},
					{name = sg_Para[3], blueprint = SBP.ALLIES.PARATROOPER, timer = "Para3", timeramount = 5, ordersgiven = false, spawned = false},
					{name = sg_Para[4], blueprint = SBP.ALLIES.PARATROOPER, timer = "Para4", timeramount = 5, ordersgiven = false, spawned = false},
					{name = sg_Para[5], blueprint = SBP.ALLIES.PARATROOPER_AT_57MM, timer = "Para5", timeramount = 5, ordersgiven = false, spawned = false},
				}
	
	-- starts the first paradrop timer
	--Timer_Start(t_ParaDrop[1].timer, t_ParaDrop[1].timeramount)
	
	
	Rule_AddInterval(Rule_ParaDropSpawn, 5)
	Rule_AddInterval(Rule_ParaDropOrders, 5)
	
	
end


function Rule_ParaDropSpawn()


	if g_ParaIndex > table.getn(t_ParaDrop) then
	
		Rule_RemoveMe()
		print("rule removed?")
		
	else


		--for k, v in pairs(t_ParaDrop) do
			
			
			
			if SGroup_IsEmpty(t_ParaDrop[g_ParaIndex].name) == true and t_ParaDrop[g_ParaIndex].spawned == false then
			
				print(g_ParaIndex)
			
				l_randomdrop = Util_GetRandomPosition(mkr_RandomParaDrop)
				
				Util_Paradrop(g_CreepPlayer, t_ParaDrop[g_ParaIndex].name, t_ParaDrop[g_ParaIndex].blueprint, l_randomdrop, 1)
				
				t_ParaDrop[g_ParaIndex].spawned = true
				
				Timer_Start(t_ParaDrop[g_ParaIndex].timer, t_ParaDrop[g_ParaIndex].timeramount)
				
				g_ParaIndex = g_ParaIndex + 1
				
			end
			
		--end

			

	end
end


-- mkr_RandomParaDrop
function Rule_ParaDropOrders()

	local l_CreepProgression = t_CreepWaveInfo[g_WaveProgression]
	local l_SubWaveProgression = l_CreepProgression.spawnInfo[g_RandomCompositionInside]
	
	local sg_PotentialPlayerSquads = SGroup_CreateIfNotFound("sg_PotentialPlayerSquads")
	local eg_PotentialPlayerEntities = EGroup_CreateIfNotFound("eg_PotentialPlayerEntities")
	local eg_EGroupTarget = EGroup_CreateIfNotFound("eg_EGroupTarget")
	
	local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
			
	l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
			
	
	
	for k, v in pairs(t_ParaDrop) do

		if SGroup_IsEmpty(v.name) == false and math.floor(Timer_GetRemaining(v.timer)) <= 0 and SGroup_IsIdle(v.name, ALL) == true  then
			
		
			for k, v in pairs(t_PlayerHumanInfo) do
			
				Player_GetAll(v.playerID)
				--SGroup_AddGroup(sg_PotentialPlayerSquads, sg_allsquads)
				EGroup_AddEGroup(eg_PotentialPlayerEntities, eg_allentities)
				
				EGroup_Filter(eg_PotentialPlayerEntities, {EBP.SP.ALLY_2ND_MOTORPOOL_INVASION, EBP.SP.AXIS_COMMAND_INVASION}, FILTER_REMOVE)
			
			end
			
			
			-- have to do this here because paradropped troops don't register as soon as they're spawned
			if SGroup_ContainsSGroup(sg_ParaOverGroup, v.name, ANY) == false then
			
				SGroup_AddGroup(sg_ParaOverGroup, v.name)
				Cmd_InstantUpgrade(v.name, UPG.ALLIES.PARATROOPER_AT, 1)
				
			end
			if SGroup_ContainsSGroup(sg_CreepOverGroup, v.name, ANY) == false then
			
				SGroup_AddGroup(sg_CreepOverGroup, v.name)
				
				
				
				
			end
			
			Spawn_Ping(v.name)
			
			EGroup_Add(eg_EGroupTarget, EGroup_GetRandomSpawnedEntity(eg_PotentialPlayerEntities))
			
			
			if EGroup_IsEmpty(eg_EGroupTarget) == false then
				
				--Cmd_AttackMove(v.name, Entity_GetPosition(EGroup_GetRandomSpawnedEntity(eg_PotentialPlayerEntities)), nil, nil, 40)
				
				if SGroup_ContainsBlueprints(v.name, SBP.ALLIES.PARATROOPER, ALL) then
					
					Cmd_Ability(v.name, ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, eg_EGroupTarget, nil, false, nil)
					
				elseif SGroup_ContainsBlueprints(v.name, SBP.ALLIES.PARATROOPER_AT_57MM, ANY) then
					
					if SGroup_IsUnderAttack(v.name, ANY, 5) == true then
						
						local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
						
						SGroup_GetLastAttacker(v.name, l_lastattacker)
						
						if SGroup_IsEmpty(l_lastattacker) == false and SGroup_ContainsBlueprints(l_lastattacker, t_VehicleTable, ANY) == true then
							
							SGroup_Filter(l_lastattacker, t_VehicleTable, FILTER_KEEP)
							
						elseif SGroup_IsEmpty(l_lastattacker) == false and SGroup_ContainsBlueprints(l_lastattacker, t_VehicleTable, ANY) == false then
							
							Cmd_Attack(v.name, l_lastattacker)
							
						end
						
					else
						
						Cmd_Attack(v.name, eg_EGroupTarget, nil, nil, 40)
						
					end
					
				end
				
				EGroup_Clear(eg_EGroupTarget)
				
			elseif SGroup_IsEmpty(l_humanConcentration) == false then
				
				if SGroup_ContainsBlueprints(v.name, SBP.ALLIES.PARATROOPER, ALL) then
					
					if SGroup_IsDoingAbility(v.name, ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, ALL) == false then
						
						Cmd_Ability(v.name, ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, l_humanConcentration, nil, false, nil)
						
					end
					
				elseif SGroup_ContainsBlueprints(v.name, SBP.ALLIES.PARATROOPER_AT_57MM, ANY) then
					
					Cmd_AttackMove(v.name, Squad_GetPosition(SGroup_GetRandomSpawnedSquad(l_humanConcentration)), nil, nil, 40)
					--v.ordersgiven = true
					
				end
				
			end
			
		elseif SGroup_IsEmpty(v.name) == false and math.floor(Timer_GetRemaining(v.timer)) <= 0 and SGroup_IsIdle(v.name, ALL) == false then
			
			if EGroup_IsEmpty(eg_EGroupTarget) == false then
				
				--Cmd_AttackMove(v.name, Entity_GetPosition(EGroup_GetRandomSpawnedEntity(eg_PotentialPlayerEntities)), nil, nil, 40)
				
				if SGroup_ContainsBlueprints(v.name, SBP.ALLIES.PARATROOPER, ALL) then
					
					Cmd_Ability(v.name, ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, eg_EGroupTarget, nil, false, nil)
					
				elseif SGroup_ContainsBlueprints(v.name, SBP.ALLIES.PARATROOPER_AT_57MM, ANY) then
					
					if SGroup_IsUnderAttack(v.name, ANY, 5) == true then
						
						local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
						
						SGroup_GetLastAttacker(v.name, l_lastattacker)
						
						if SGroup_IsEmpty(l_lastattacker) == false and SGroup_ContainsBlueprints(l_lastattacker, t_VehicleTable, ANY) == true then
							
							SGroup_Filter(l_lastattacker, t_VehicleTable, FILTER_KEEP)
							Cmd_Attack(v.name, l_lastattacker)
							
						elseif SGroup_IsEmpty(l_lastattacker) == false and SGroup_ContainsBlueprints(l_lastattacker, t_VehicleTable, ANY) == false then
							
							Cmd_Attack(v.name, l_lastattacker)
							
						end
						
					else
						
						Cmd_Attack(v.name, eg_EGroupTarget, nil, nil, 40)
						
					end
					
				end
				
				EGroup_Clear(eg_EGroupTarget)
				
			elseif SGroup_IsEmpty(l_humanConcentration) == false then
				
				if SGroup_ContainsBlueprints(v.name, SBP.ALLIES.PARATROOPER, ALL) then
					
					if SGroup_IsDoingAbility(v.name, ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, ALL) == false then
						
						Cmd_Ability(v.name, ABILITY.ALLIES.SATCHEL_CHARGE_NOREQS, l_humanConcentration, nil, false, nil)
						
					end
					
				elseif SGroup_ContainsBlueprints(v.name, SBP.ALLIES.PARATROOPER_AT_57MM, ANY) then
					
					Cmd_AttackMove(v.name, Squad_GetPosition(SGroup_GetRandomSpawnedSquad(l_humanConcentration)), nil, nil, 40)
					
				end
				
			end
		end
	end
	
end
---------------------=====================


-- timer function that automatically checks to see if the current wave timer has expired, etc.
function Rule_CreepSpawnTimer()

	local l_CreepProgression = t_CreepWaveInfo[g_WaveProgression]
	local l_SubWaveProgression = l_CreepProgression.spawnInfo[g_RandomCompositionInside]
		
		if (g_CreepGroupsSpawned < l_CreepProgression.maxGroupNumber and math.floor(Timer_GetRemaining( l_CreepProgression.tmrSpawn )) == 0 and g_CreepBackupTimerStarted == false) then
			
			-- randomize spawn only if wave progression is > 1
				if g_WaveProgression > 1 then
					
					local l_RandomSpawnSelector = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals))
					
					if l_RandomSpawnSelector == g_LastRandomSpawnSelected then
						
						if l_RandomSpawnSelector >= table.getn(t_SpawnLocationsAndGoals) then
							
							l_RandomSpawnSelector = 1
							
						elseif l_RandomSpawnSelector == 1 and (table.getn(t_SpawnLocationsAndGoals) > 1) then
							
							l_RandomSpawnSelector = l_RandomSpawnSelector + 1
							
						else
							if (l_RandomSpawnSelector + 1) <= table.getn(t_SpawnLocationsAndGoals) then
								
								l_RandomSpawnSelector = l_RandomSpawnSelector + 1
								
							elseif (l_RandomSpawnSelector - 1 ) > 0 then
								
								l_RandomSpawnSelector = l_RandomSpawnSelector - 1
								
							end
						end
						
					end
					
					g_SpawnIndex = l_RandomSpawnSelector
					g_LastRandomSpawnSelected = l_RandomSpawnSelector
					
					g_CreepSpawnLocation = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].spawnlocation -- to initialize initial spawn location
					g_CreepSpawnDirection = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].direction -- to initialize spawn direction
					print("randomized spawn?")
					print("spawn point is... "..Marker_GetName(g_CreepSpawnLocation))
					
					
				end
				
				if l_SubWaveProgression[g_SubWave].spawnNumber <= l_SubWaveProgression[g_SubWave].totalNumber --and SGroup_IsEmpty(l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]) 
					and SGroup_IsEmpty(l_SubWaveProgression.overGroupName) == false then
					
					local l_RandomComposition = World_GetRand(1, table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType))
					
					if l_RandomComposition == g_LastRandomCompositionTableNumber then
						
						if l_RandomComposition >= table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) then
							
							l_RandomComposition = 1
							
						elseif l_RandomComposition == 1 and (table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) > 1) then
							
							l_RandomComposition = l_RandomComposition + 1
							
						else
							if (l_RandomComposition + 1) <= table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) then
								
								l_RandomComposition = l_RandomComposition + 1
								
							elseif (l_RandomComposition - 1 ) > 0 then
								
								l_RandomComposition = l_RandomComposition - 1
								
							end
						end
						
					end
					
					local l_RandomCompositionInside = t_CreepWaveInfo[g_WaveProgression].compositionType[l_RandomComposition]
					g_RandomCompositionInside = l_RandomCompositionInside
					g_LastRandomCompositionTableNumber = l_RandomComposition -- different than g_RandomCompositionInside in that it's a table value, not the composition itself
					
					local l_SubWaveProgression2 = l_CreepProgression.spawnInfo[g_RandomCompositionInside]
					
					if SGroup_IsEmpty(l_SubWaveProgression2.overGroupName) == true then	
				
						l_CreepProgression = t_CreepWaveInfo[g_WaveProgression] -- update latest creep progression
						PlayInvasionTypeDetermine(l_CreepProgression.consistsof)
						
						Rule_AddDelayedIntervalEx(Rule_CreepDropArtillery, 1, 1, 1)
						
						Rule_RemoveMe()
					end
					
				elseif l_SubWaveProgression[g_SubWave].spawnNumber <= l_SubWaveProgression[g_SubWave].totalNumber --and SGroup_IsEmpty(l_SubWaveProgression[g_SubWave].creepMemberName[l_SubWaveProgression[g_SubWave].spawnNumber]) 
					and SGroup_IsEmpty(l_SubWaveProgression.overGroupName) == true then
					
					local l_RandomComposition = World_GetRand(1, table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType))
					
					if l_RandomComposition == g_LastRandomCompositionTableNumber then
						
						if l_RandomComposition >= table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) then
							
							l_RandomComposition = 1
							
						elseif l_RandomComposition == 1 and (table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) > 1) then
							
							l_RandomComposition = l_RandomComposition + 1
							
						else
							if (l_RandomComposition + 1) <= table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) then
								
								l_RandomComposition = l_RandomComposition + 1
								
							elseif (l_RandomComposition - 1 ) > 0 then
								
								l_RandomComposition = l_RandomComposition - 1
								
							end
						end
						
					end
					
					local l_RandomCompositionInside = t_CreepWaveInfo[g_WaveProgression].compositionType[l_RandomComposition]
					g_RandomCompositionInside = l_RandomCompositionInside
					g_LastRandomCompositionTableNumber = l_RandomComposition -- different than g_RandomCompositionInside in that it's a table value, not the composition itself
					
					l_CreepProgression = t_CreepWaveInfo[g_WaveProgression] -- update latest creep progression
					PlayInvasionTypeDetermine(l_CreepProgression.consistsof)
					
					Rule_AddDelayedIntervalEx(Rule_CreepDropArtillery, 1, 1, 1)
				
					Rule_RemoveMe()
				
				end
		
	elseif (g_CreepBackupTimerStarted == true and g_CreepGroupsSpawned >= l_CreepProgression.maxGroupNumber and math.floor(Timer_GetRemaining(g_CreepBackupTimerName)) <= 0) then 
		
		if g_WaveProgression < g_CreepWaveCount then
			
			g_WaveProgression = g_WaveProgression + 1 -- iterates to next wave once time runs out
			g_CreepGroupsSpawned = 0
			g_CreepBackupTimerStarted = false
			
			
			if g_WaveProgression >= g_CreepWaveCount then
			
				t_wavetext = {
					{g_Actor, 10000030}, -- Incoming wave text
				}
				
				fg_EndFlag = true
				
				Rule_AddInterval(Rule_CreepBackupTimer, 1)
				
				-- randomize spawn only if wave progression is > 1
				if g_WaveProgression > 1 then
					
					local l_RandomSpawnSelector = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals))
					
					if l_RandomSpawnSelector == g_LastRandomSpawnSelected then
					
						if l_RandomSpawnSelector >= table.getn(t_SpawnLocationsAndGoals) then
						
							l_RandomSpawnSelector = 1
							
						elseif l_RandomSpawnSelector == 1 and (table.getn(t_SpawnLocationsAndGoals) > 1) then
						
							l_RandomSpawnSelector = l_RandomSpawnSelector + 1
						
						else
							if (l_RandomSpawnSelector + 1) <= table.getn(t_SpawnLocationsAndGoals) then
							
								l_RandomSpawnSelector = l_RandomSpawnSelector + 1
								
							elseif (l_RandomSpawnSelector - 1 ) > 0 then
						
								l_RandomSpawnSelector = l_RandomSpawnSelector - 1
								
							end
						end
						
					end
						
					
					
					g_SpawnIndex = l_RandomSpawnSelector
					g_LastRandomSpawnSelected = l_RandomSpawnSelector
					
					g_CreepSpawnLocation = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].spawnlocation -- to initialize initial spawn location
					g_CreepSpawnDirection = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].direction -- to initialize spawn direction
				end
				
				local l_RandomComposition = World_GetRand(1, table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType))
				
				if l_RandomComposition == g_LastRandomCompositionTableNumber then
					
					if l_RandomComposition >= table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) then
						
						l_RandomComposition = 1
						
					elseif l_RandomComposition == 1 and (table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) > 1) then
						
						l_RandomComposition = l_RandomComposition + 1
						
					else
						if (l_RandomComposition + 1) <= table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) then
							
							l_RandomComposition = l_RandomComposition + 1
							
						elseif (l_RandomComposition - 1 ) > 0 then
					
							l_RandomComposition = l_RandomComposition - 1
							
						end
					end
					
				end
				
				local l_RandomCompositionInside = t_CreepWaveInfo[g_WaveProgression].compositionType[l_RandomComposition]
				g_RandomCompositionInside = l_RandomCompositionInside
				g_LastRandomCompositionTableNumber = l_RandomComposition -- different than g_RandomCompositionInside in that it's a table value, not the composition itself
				
				
				local l_tempTotal = 0
				
				for i = 1, table.getn(t_PlayerHumanInfo) do
					
					t_PlayerHumanInfo[i].individualTotalScore = t_PlayerHumanInfo[i].individualTotalScore + l_CreepProgression.waveBonus - g_WaveBonusPenalty -- adds bonus score to player when they survive to next wave
					
					t_PlayerHumanInfo[i].bonusScore = t_PlayerHumanInfo[i].bonusScore + l_CreepProgression.waveBonus - g_WaveBonusPenalty
					
					l_tempTotal = l_tempTotal + t_PlayerHumanInfo[i].individualTotalScore
					
					print("wave survived, bonus .."..l_CreepProgression.waveBonus.." added to individual "..i)
					
					print("indiv score after bonus added is "..t_PlayerHumanInfo[i].individualTotalScore)
					print("l_tempTotal is now "..l_tempTotal)
					
				end
				
				l_CreepProgression = t_CreepWaveInfo[g_WaveProgression] -- update latest creep progression
				PlayInvasionTypeDetermine(l_CreepProgression.consistsof)
				Rule_AddOneShot(DisplayCurrentWave, 5)
				
				Rule_AddDelayedIntervalEx(Rule_CreepDropArtillery, 1, 1, 1)
				
				Rule_RemoveMe()
				
			else
				
				Rule_AddInterval(Rule_CreepBackupTimer, 1)
				
				-- randomize spawn only if wave progression is > 1
				if g_WaveProgression > 1 then
					
					local l_RandomSpawnSelector = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals))
					
					if l_RandomSpawnSelector == g_LastRandomSpawnSelected then
						
						if l_RandomSpawnSelector >= table.getn(t_SpawnLocationsAndGoals) then
							
							l_RandomSpawnSelector = 1
							
						elseif l_RandomSpawnSelector == 1 and (table.getn(t_SpawnLocationsAndGoals) > 1) then
							
							l_RandomSpawnSelector = l_RandomSpawnSelector + 1
							
						else
							if (l_RandomSpawnSelector + 1) <= table.getn(t_SpawnLocationsAndGoals) then
								
								l_RandomSpawnSelector = l_RandomSpawnSelector + 1
								
							elseif (l_RandomSpawnSelector - 1 ) > 0 then
								
								l_RandomSpawnSelector = l_RandomSpawnSelector - 1
								
							end
						end
						
					end
					
					g_SpawnIndex = l_RandomSpawnSelector
					g_LastRandomSpawnSelected = l_RandomSpawnSelector
					g_CreepSpawnLocation = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].spawnlocation -- to initialize initial spawn location
					g_CreepSpawnDirection = t_SpawnLocationsAndGoals[l_RandomSpawnSelector].direction -- to initialize spawn direction
					print("randomized spawn?")
					print("spawn point is... "..Marker_GetName(g_CreepSpawnLocation))
					
				end
				
				--local l_RandomComposition = World_GetRand(1, table.getn(t_CreepWaveInfo[g_WaveProgression].spawnInfo))
				local l_RandomComposition = World_GetRand(1, table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType))
				
				if l_RandomComposition == g_LastRandomCompositionTableNumber then
					
					if l_RandomComposition >= table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) then
						
						l_RandomComposition = 1
						
					elseif l_RandomComposition == 1 and (table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) > 1) then
						
						l_RandomComposition = l_RandomComposition + 1
						
					else
						if (l_RandomComposition + 1) <= table.getn(t_CreepWaveInfo[g_WaveProgression].compositionType) then
							
							l_RandomComposition = l_RandomComposition + 1
							
						elseif (l_RandomComposition - 1 ) > 0 then
							
							l_RandomComposition = l_RandomComposition - 1
							
						end
					end
					
				end
					
				local l_RandomCompositionInside = t_CreepWaveInfo[g_WaveProgression].compositionType[l_RandomComposition]
				g_RandomCompositionInside = l_RandomCompositionInside
				g_LastRandomCompositionTableNumber = l_RandomComposition -- different than g_RandomCompositionInside in that it's a table value, not the composition itself
				
				local l_tempTotal = 0
				
				for i = 1, table.getn(t_PlayerHumanInfo) do
					
					t_PlayerHumanInfo[i].individualTotalScore = t_PlayerHumanInfo[i].individualTotalScore + l_CreepProgression.waveBonus - g_WaveBonusPenalty -- adds bonus score to player when they survive to next wave
					
					t_PlayerHumanInfo[i].bonusScore = t_PlayerHumanInfo[i].bonusScore + l_CreepProgression.waveBonus - g_WaveBonusPenalty
					
					l_tempTotal = l_tempTotal + t_PlayerHumanInfo[i].individualTotalScore
					
					print("wave survived, bonus .."..l_CreepProgression.waveBonus.." added to individual "..i)
					print("indiv score after bonus added is "..t_PlayerHumanInfo[i].individualTotalScore)
					print("l_tempTotal is now "..l_tempTotal)
				end
				
				
				-- have to redefine t_wavetext to reflect current wave!
				t_wavetext = {
					{g_Actor, 10000027}, -- Incoming!! The enemy has sent another force to attack us!
				}
				
				l_CreepProgression = t_CreepWaveInfo[g_WaveProgression] -- update latest creep progression
				
				if l_CreepProgression.boss == false and l_CreepProgression.lastboss == false then
					
					PlayInvasionTypeDetermine(l_CreepProgression.consistsof)
					Rule_AddOneShot(DisplayCurrentWave, 5)
					
				else
					
					Rule_AddOneShot(DisplayCurrentWave, 23)
					
					
				end
				
				Rule_AddDelayedIntervalEx(Rule_CreepDropArtillery, 1, 1, 1)
				Rule_RemoveMe()
				
			end
			
		end
	end

end



function Rule_CreepBackupTimer()

	--print("backuptimer started!")
	local l_CreepProgression = t_CreepWaveInfo[g_WaveProgression]
	
--~ 	if g_KillCount >= l_CreepProgression.killCountThreshold and g_CreepBackupTimerStarted == false and 
--~ 	((SGroup_IsEmpty(sg_CreepOverGroup) == false and SGroup_Count(sg_CreepOverGroup) <=2 ) or SGroup_IsEmpty(sg_CreepOverGroup) == true) then

	if g_CreepBackupTimerStarted == false and g_CreepGroupsSpawned >= l_CreepProgression.maxGroupNumber and 
		((SGroup_IsEmpty(sg_CreepOverGroup) == false and SGroup_TotalMembersCount(sg_CreepOverGroup) <= 15 ) or SGroup_IsEmpty(sg_CreepOverGroup) == true) then
		--and fg_EndFlag == false	then

		local l_sendnextwave = true
		
		if l_CreepProgression.boss == true then
		
			if Rule_CreepSpawnValueDeterminer() > 8 then -- value of boss units
		
				l_sendnextwave = false
			
			end
			
		end
			
		if l_sendnextwave == true then
		
			if fg_EndFlag == false then
			
				print("backup timer supposed to be started")
				
				local l_minutes = math.floor(l_CreepProgression.timeToNextWave/60)
				local l_convertedmin = Loc_ConvertNumber(l_minutes)
				local l_seconds = math.floor(l_CreepProgression.timeToNextWave - (l_minutes * 60))
				local l_timerstring
				local l_convertedsecs
				
				if l_seconds < 10 then
					
					-- so we're faking it, if it's less than 10 seconds then we'll pretend it's a round minute because we can't put the 0 in front of the single-digit number without changing the loc string
					l_timerstring = Loc_FormatText(10000051, l_convertedmin, 10000052)
					
				else
					
					l_convertedsecs = Loc_ConvertNumber(l_seconds)
					l_timerstring = Loc_FormatText(10000051, l_convertedmin, l_convertedsecs)
					
				end
				
				Timer_Start(g_CreepBackupTimerName, l_CreepProgression.timeToNextWave) -- starts timer with next wave
				Objective_UpdateText(OBJ_Defend_HQ, l_timerstring, l_timerstring, true) -- "Time until next attack wave"
				Objective_Show(OBJ_Defend_HQ, true)
				Objective_StartTimer(OBJ_Defend_HQ, COUNT_DOWN, l_CreepProgression.timeToNextWave, -1)
				Objective_UpdateText(OBJ_Defend_HQ, 10000050, 10000050, false) -- "Time until next attack wave"
				g_CreepBackupTimerStarted = true
				Rule_AddOneShot(Rule_WaveTimerRemove, l_CreepProgression.timeToNextWave)
				
				-- Resource rewards added when wave is survived and timer started
				WaveResourceBonus()
				
			end
			
			Rule_RemoveMe()
		end
--~ 	elseif ((g_KillCount < l_CreepProgression.killCountThreshold) or ((g_KillCount <= l_CreepProgression.killCountThreshold) and l_CreepProgression.boss == true)) 
--~ 		and g_CreepBackupTimerStarted == true and (math.floor(Timer_GetRemaining(g_CreepBackupTimerName)) <= 0) then

	elseif g_CreepBackupTimerStarted == true and (math.floor(Timer_GetRemaining(g_CreepBackupTimerName)) <= 0) then
		
		print("backup timer supposed to be stopped")
		Objective_StopTimer(OBJ_Defend_HQ)
		Objective_Show(OBJ_Defend_HQ, false)
		Timer_End(g_CreepBackupTimerName)
		
		Rule_RemoveMe()
	
		--g_CreepBackupTimerStarted = false
		
	end
	
end



function Rule_WaveTimerRemove()
	print("wave timer removed?")
	Objective_StopTimer(OBJ_Defend_HQ)
	Objective_Show(OBJ_Defend_HQ, false)
	
end

-- grabs the greatest number of player built squads, on a player by player basis.  ie. player 2 has 3 built units, vs player 1's 2, so player 2's units are targetted.
function Rule_GetPlayerUnitConcentration(getplayerconcentration)
	
	local tempreturnconcentration_unit = getplayerconcentration

	if tempreturnconcentration_unit == nil then
			
		tempreturnconcentration_unit = SGroup_CreateIfNotFound("emptysgroup") -- prevents nil from occuring if no enemies
		
	end
	
	
	for i = 1, table.getn(t_PlayerHumanInfo) do
		local l_tempcon = Player_GetSquadConcentration(t_PlayerHumanInfo[i].playerID)
		
		if l_tempcon ~= nil then
			
			if SGroup_TotalMembersCount(l_tempcon) > SGroup_TotalMembersCount(tempreturnconcentration_unit) then
				
				tempreturnconcentration_unit = l_tempcon
				
			else
				
			end
			
		end
		
	end
	
	return tempreturnconcentration_unit

end


function Rule_GetPlayerEntityConcentration(getplayerentityconcentration)

	local tempreturnconcentration = getplayerentityconcentration

	if tempreturnconcentration == nil then
				
		tempreturnconcentration = EGroup_CreateIfNotFound("emptyegroup") -- prevents nil from occuring if no enemies
			
	end
		
							
	for i = 1, table.getn(t_PlayerHumanInfo) do
		local l_tempcon = Player_GetEntityConcentration(t_PlayerHumanInfo[i].playerID)
	
		if l_tempcon ~= nil then
		
			if EGroup_CountSpawned(l_tempcon) > EGroup_CountSpawned(tempreturnconcentration) then
			
				tempreturnconcentration = l_tempcon
				
			else
				
			end
		
		end
		
	end
	
	return tempreturnconcentration

end

function Rule_GetPlayerEntityConcentration_Rocket(getplayerentityconcentration)

	local tempreturnconcentration_entity = getplayerentityconcentration

	if tempreturnconcentration_entity == nil then
		
		tempreturnconcentration_entity = EGroup_CreateIfNotFound("emptyegroup") -- prevents nil from occuring if no enemies
		
	end
	
	
	for i = 1, table.getn(t_PlayerHumanInfo) do
		
		local l_tempcon = EGroup_CreateIfNotFound("l_tempcon")
		Player_GetAllEntitiesNearMarker(t_PlayerHumanInfo[i].playerID, l_tempcon, mkr_buildable_area)
		
		if l_tempcon ~= nil then

			if EGroup_CountSpawned(l_tempcon) > EGroup_CountSpawned(tempreturnconcentration_entity) then
			
				tempreturnconcentration_entity = l_tempcon
				
			else
				
			end
		
		end
		
	end
	
	return tempreturnconcentration_entity

end


-- behaviour control. removes squad from t_SpawnedSquadInfo if it didn't exist
function Rule_CreepNextAttack()
	
	
	--if g_LastBuildingDestroyed == true then
		
		--Rule_RemoveMe()
		
	--else
		
		-- for every squad spawned
		for k,v in pairs(t_SpawnedSquadInfo) do
			
			-- if the squad is not empty
			if SGroup_IsEmpty(v.name) == false then
				
				-- checks to see what "role" it is - "defender", "heavy", or "vehicle"
				-- if a "defender" then...
				if (v.role == t_RoleType[1]) then
					
					Creep_DefenderBehaviour(v.name, v)
					
				-- if a "heavy" then...
				elseif (v.role == t_RoleType[2]) then
					
					Creep_HeavyBehaviour(v.name,  v)
				
				-- if a "vehicle" then...
				elseif (v.role == t_RoleType[3]) then
					
					Creep_VehicleBehaviour(v.name, v)
					
				-- if a "rocket" then...
				elseif (v.role == t_RoleType[4]) then
					
					Creep_RocketBehaviour(v.name, v)
					
				-- if a "flamer" type then...	
				elseif (v.role == t_RoleType[5]) then
					
					Creep_FlamerBehaviour(v.name, v)
					
				-- if a "building" type then...	
				elseif (v.role == t_RoleType[6]) then
					
					Creep_BuildingBehaviour(v.name, v.spawnindex, v)	
					
					-- if a "sniper" type then...	
				elseif (v.role == t_RoleType[7]) then
					
					Creep_SniperBehaviour(v.name, v.spawnindex, v)	
					
					-- if an "LMG" type then...	
				elseif (v.role == t_RoleType[8]) then
					
					Creep_LMGBehaviour(v.name, v)		
					
					-- if a "demo" type then...	
				elseif (v.role == t_RoleType[9]) then
					
					Creep_DemoBehaviour(v.name, v)					
				
					-- if an "escort" type then...	
				elseif (v.role == t_RoleType[10]) then
					
					Creep_EscortBehaviour(v.name, v)		
				
					-- if a "repair" type then
				elseif (v.role == t_RoleType[11]) then
					
					Creep_RepairBehaviour(v.name, v)
					
				elseif (v.role == t_RoleType[12]) then
					
					Creep_NebelBehaviour(v.name, v)	
					
				elseif (v.role == t_RoleType[13]) then
					
					Creep_HMGBehaviour(v.name, v.spawnindex, v)		
				
				elseif (v.role == t_RoleType[14]) then
					
					Creep_MortarBehaviour(v.name, v)					
				
				elseif (v.role == t_RoleType[15]) then
				
					Creep_VehicleEscortBehaviour(v.name, v)
				
				
				elseif (v.role == t_RoleType[16]) then
				
					Creep_ATBehaviour(v.name, v)
					
				elseif (v.role == t_RoleType[17]) then
				
					Creep_CamoSniperBehaviour(v.name, v.spawnindex, v)	
				
				elseif (v.role == t_RoleType[18]) then
					
					Creep_CalliopeBehaviour(v.name, v)
					
				
				-- if everything else...
				else
				
					if SGroup_IsIdle(v.name, ANY) then
						--print("everything else")
						
						if EGroup_IsEmpty(v.target) == false then
							
							--Cmd_AttackMove(v.name, v.target, false , nil, 10)
							Cmd_Attack(v.name, v.target)
							
						elseif EGroup_IsEmpty(v.target) == true then -- if this squad's target is destroyed then attack the default current target
							
							for i =1, table.getn(t_TargetTable) do
							
								if t_TargetTable[i].destroyed == false then
							
									v.target = t_TargetTable[i].name
							
									--g_CreepObjective = t_TargetTable[i].name -- records the current default target as the unit's current target
							
								end
							
							end
							
							--v.target = t_TargetTable[g_TargetIndexNum].name -- records the current default target as the unit's current target
							
							--Cmd_AttackMove(v.name, v.target, false , nil, 10)
							--Cmd_Attack(v.name, g_CreepObjective)
							Cmd_Attack(v.name, v.target)
						end
						
						
					end
				end
				
			-- if there is no such sgroup then remove it from the list	
			elseif SGroup_IsEmpty(v.name) == true then
				
				table.remove(t_SpawnedSquadInfo, k)
				
			end
			
		end
		
	--end

end



function Creep_DefenderBehaviour(victimgroup, victimtable)

	local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")


	-- if the squad is under attack
	if SGroup_IsUnderAttack(victimgroup, ANY, 2) then 

		--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			-- if attacker and last attacker are same...
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
			else
				-- if last attacker isnt' empty, attackmove
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
					
						-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 2)
						
						if l_randomattacktype == 1 then
						
							
							GrenadeBehaviour(victimgroup, victimtable, l_lastattacker)	
							
						else
						
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_lastattacker)
							
						end
					
					end
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
					local l_randomattacktype = World_GetRand(1, 2)
							
					if l_randomattacktype == 1 then
					
						
					
						GrenadeBehaviour(victimgroup, victimtable, victimtable.attacker)	
						
					else
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, victimtable.attacker)
						
					end
				
				end
		
		
		end
		
	-- if the over group is under attack
	elseif SGroup_IsEmpty(sg_CreepOverGroup) == false and SGroup_IsUnderAttack(sg_CreepOverGroup, ANY, 2) then
			

	--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(sg_CreepOverGroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
			else
			
				if SGroup_IsEmpty(l_lastattacker) == false then
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
					
						-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 2)
						
						if l_randomattacktype == 1 then
						
							
							GrenadeBehaviour(victimgroup, victimtable, l_lastattacker)
							
						else
						
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_lastattacker)
							
						end
					
					end
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
					local l_randomattacktype = World_GetRand(1, 2)
							
					if l_randomattacktype == 1 then
					
						
					
						GrenadeBehaviour(victimgroup, victimtable, victimtable.attacker)	
						
					else
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, victimtable.attacker)
						
					end
				
				end
		
		
		end		
		
	-- if the squad is idle, then move to target everyone else should be fighting
	elseif SGroup_IsEmpty(sg_CreepOverGroup) == false and SGroup_IsIdle(victimgroup, ANY) then
		
--~ 		Cmd_Move(victimgroup, sg_CreepOverGroup, nil, nil, nil, nil, nil, 40)	
--~ 		--Cmd_Move(victimgroup, currenttarget, nil, nil, nil, nil, nil, 40)	
--~ 		
		local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
			
		l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
			
		if SGroup_IsEmpty(l_humanConcentration) == false then
			
			--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
			
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
					-- one in 3 chance of grenade attack!
				local l_randomattacktype = World_GetRand(1, 2)
						
				if l_randomattacktype == 1 then
				
						
					GrenadeBehaviour(victimgroup, victimtable, l_humanConcentration)	
						
				else
					
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_humanConcentration)
					
				end
			
			end
			
		elseif SGroup_IsEmpty(l_humanConcentration) == true then
			
			--Cmd_AttackMove(victimgroup, mkr_KamikazeDestination, nil, nil, 40)

			--Cmd_Move(victimgroup, victimgroup, nil, nil, nil, nil, nil, 50)	
			
			
			for i = 1, table.getn(t_PlayerHumanInfo) do
		
				-- local building check
				local l_tempBuildingEmpty = EGroup_IsEmpty(t_PlayerHumanInfo[i].building)
					
				-- local secondary building check
				local l_tempSecondaryBuildingEmpty = EGroup_IsEmpty(t_PlayerHumanInfo[i].secondaryBuilding)
					
				if l_tempBuildingEmpty == false then

					Cmd_AttackMove(victimgroup, t_PlayerHumanInfo[i].building, nil, nil, 20)
					
				elseif l_tempBuildingEmpty == true then
				
					Cmd_AttackMove(victimgroup, mkr_KamikazeDestination, nil, nil, 40)
				
				end
		
		
			end
			
			
			
		end		
		
	end
end

function Creep_HeavyBehaviour(victimgroup, victimtable)


	local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
	-- if the squad is under attack
	if SGroup_IsUnderAttack(victimgroup, ANY, 2) then 
		
		--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
			else
			
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
					-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 2)
								
						if l_randomattacktype == 1 then
						
							
						
							GrenadeBehaviour(victimgroup, victimtable, l_lastattacker)	
							
						else
							
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_lastattacker)
							
						end
					
					end
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
		
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
					local l_randomattacktype = World_GetRand(1, 2)
							
					if l_randomattacktype == 1 then
					
						
					
						GrenadeBehaviour(victimgroup, victimtable, victimtable.attacker)	
						
					else
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, victimtable.attacker)
						
					end
				
			end
		
		
		end


		-- if the squad is idle, then attack the targets everything else is attacking
	elseif SGroup_IsIdle(victimgroup, ANY) then
	
	
		if EGroup_IsEmpty(victimtable.target) == false then
			
			--Cmd_AttackMove(victimgroup, v.target, false , nil, 10)
			Cmd_Attack(victimgroup, victimtable.target)
			
		elseif EGroup_IsEmpty(victimtable.target) == true then -- if this squad's target is destroyed then attack the default current target
			
			
			local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
			
			l_entityConcentration = Rule_GetPlayerEntityConcentration(l_entityConcentration)
				
				
			if EGroup_IsEmpty(l_entityConcentration) == false then
							
				--Cmd_AttackMove(v.name, v.target, false , nil, 10)
				Cmd_Attack(victimgroup, l_entityConcentration)
			else
			
				local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
				
				
				l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
				
				
				if SGroup_IsEmpty(l_humanConcentration) == false then
					--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
					
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
					-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 2)
								
						if l_randomattacktype == 1 then
						
							
						
							GrenadeBehaviour(victimgroup, victimtable, l_humanConcentration)	
							
						else
							
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_humanConcentration)
							
						end
				
					end
			
				end
			end	
		end
		
	end


end

function Creep_VehicleBehaviour(victimgroup, victimtable)
	--vehicle itself
	if SGroup_IsUnderAttack(victimgroup, ANY, 5) then
		print("vehicle under attack")
		local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		local l_attacker_vehicle = SGroup_CreateIfNotFound("l_attacker_vehicle")
		local l_attacker_all = SGroup_CreateIfNotFound("l_attacker_all")
		
		SGroup_GetLastAttacker(victimgroup, l_lastattacker)
		
		SGroup_AddGroup(l_attacker_vehicle, l_lastattacker)
		SGroup_AddGroup(l_attacker_all, l_lastattacker)
		
		-- grabs the player's vehicles that are attacking it
		SGroup_Filter(l_attacker_vehicle, t_OppositeVehicleTable, FILTER_KEEP)
		
		--print(SGroup_ContainsBlueprints(l_lastattacker, t_OppositeVehicleTable, false))
		
		if SGroup_IsEmpty(l_attacker_vehicle) == false or SGroup_ContainsBlueprints(victimtable.attacker, t_OppositeVehicleTable, false) then
			
			print("inside!")
			
			if SGroup_Compare(l_attacker_vehicle, victimtable.attacker) then
			
			else
				--Cmd_Attack(victimgroup, l_attacker_vehicle)
				if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				local l_randomattacktype = World_GetRand(1, 3)
					
					if l_randomattacktype == 1 then
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankLeftFront, l_attacker_vehicle)
						
					elseif l_randomattacktype ==2 then
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankRightFront, l_attacker_vehicle)
						
					elseif l_randomattacktype ==3 then
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.MaximizeRange, l_attacker_vehicle)
						
					end
					
				end
				
				victimtable.attacker = l_attacker_vehicle
				
				SGroup_Clear(l_lastattacker)
				SGroup_Clear(l_attacker_vehicle)
				SGroup_Clear(l_attacker_all)
				
			end
			
		else
			
			if (SGroup_IsEmpty(l_attacker_all) == false) then --SGroup_IsEmpty(victimtable.attacker) and 
				
				if SGroup_Compare(l_attacker_all, victimtable.attacker) then
					
					
				else
					
					if SGroup_IsEmpty(l_attacker_all) == false then
							
						--Cmd_Attack(victimgroup, l_attacker_all)
						if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
						
							local l_randomattacktype = World_GetRand(1, 3)
							
							if l_randomattacktype == 1 then
								
								
								victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankLeftFront, l_attacker_all)
								
							elseif l_randomattacktype ==2 then
								
								victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankRightFront, l_attacker_all)
								
							elseif l_randomattacktype ==3 then
								
								victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.MaximizeRange, l_attacker_all)
								
							end
							
						end
						
						--victimtable.attacker = l_attacker_all
						
						SGroup_Clear(l_attacker_vehicle)
						SGroup_Clear(l_lastattacker)
						SGroup_Clear(l_attacker_all)
						
					end
					
				end
				
			end			
		end
		
	elseif SGroup_IsIdle(victimgroup, ANY) then
		print("Tank idle?")
		
		if EGroup_IsEmpty(victimtable.target) == false then
			
			print("attacking?")		
			--Cmd_AttackMove(v.name, v.target, false , nil, 10)
			Cmd_Attack(victimgroup, victimtable.target)
			
		elseif EGroup_IsEmpty(victimtable.target) == true then -- if this squad's target is destroyed then attack the default current target
			
			local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
			
			l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
				
				
			if SGroup_IsEmpty(l_humanConcentration) == false then
				--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
				
				if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
					
					local l_randomattacktype = World_GetRand(1, 3)
					if l_randomattacktype == 1 then
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankLeftFront, l_humanConcentration)
						
					elseif l_randomattacktype ==2 then
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankRightFront, l_humanConcentration)
						
					elseif l_randomattacktype ==3 then
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.MaximizeRange, l_humanConcentration)
						
					end
					
				end
				
			elseif SGroup_IsEmpty(l_humanConcentration) == true then
				
				local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
				
				l_entityConcentration = Rule_GetPlayerEntityConcentration(l_entityConcentration)
				
				if EGroup_IsEmpty(l_entityConcentration) == false then
					
					--Cmd_AttackMove(v.name, v.target, false , nil, 10)
					Cmd_Attack(victimgroup, l_entityConcentration)
					
				end
				
			end
			
		end
		
	end

end




function Creep_RocketBehaviour(victimgroup, victimtable)

	local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
	
	if SGroup_IsUnderAttack(victimgroup, ANY, 2) then 
		
		--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
			else
			
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
							
							-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 2)
								
--~ 						if l_randomattacktype == 1 then
--~ 						
--~ 								
--~ 							GrenadeBehaviour(victimgroup, victimtable, l_lastattacker)	
--~ 								
--~ 						else
							
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_lastattacker)
							
--~ 						end
						
					end	
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
					local l_randomattacktype = World_GetRand(1, 2)
							
--~ 					if l_randomattacktype == 1 then
--~ 					
--~ 						
--~ 					
--~ 						GrenadeBehaviour(victimgroup, victimtable, victimtable.attacker)	
--~ 						
--~ 					else
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, victimtable.attacker)
						
--~ 					end
				
				end
		
		
		end

	elseif SGroup_IsEmpty(sg_CreepOverGroup) == false and SGroup_IsUnderAttack(sg_CreepOverGroup, ANY, 2) then
			

	--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(sg_CreepOverGroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
			else
			
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
						
							-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 2)
								
--~ 						if l_randomattacktype == 1 then
--~ 						
--~ 								
--~ 							GrenadeBehaviour(victimgroup, victimtable, l_lastattacker)	
--~ 								
--~ 						else
							
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_lastattacker)
							
--~ 						end
					
					end
			
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
					local l_randomattacktype = World_GetRand(1, 2)
							
--~ 					if l_randomattacktype == 1 then
--~ 					
--~ 						
--~ 					
--~ 						GrenadeBehaviour(victimgroup, victimtable, victimtable.attacker)	
--~ 						
--~ 					else
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, victimtable.attacker)
						
--~ 					end
				
				end
		
		
		end
			
		
	else
		print("else?")
		if SGroup_IsIdle(victimgroup, ANY) then
			
			print("rocket idle?")
			print(g_LastBuildingDestroyed)
			if g_LastBuildingDestroyed == false then
			
				if EGroup_IsEmpty(victimtable.target) == true then -- if this squad's target is destroyed then attack the default current target
					print("egroup empty?")
					for i = 1, table.getn(t_TargetTable) do
						
						if t_TargetTable[i].destroyed == false then
						--print(i)
					
					
							--g_CreepObjective = t_TargetTable[i].name -- records the current default target as the unit's current target
							victimtable.defaulttarget = t_TargetTable[i].name -- records the current default target as the unit's current target
							
							break	
						end
						
					end
						
					victimtable.target = victimtable.defaulttarget -- records the current default target as the unit's current target
						
					Cmd_Attack(victimgroup, victimtable.target)
						
				else
				
					Cmd_Attack(victimgroup, victimtable.target)
					
				end
						
			elseif g_LastBuildingDestroyed == true then
				
				local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
				
				
				l_entityConcentration = Rule_GetPlayerEntityConcentration(l_entityConcentration)
				
				
				if EGroup_IsEmpty(l_entityConcentration) == false then
				
					--Cmd_AttackMove(v.name, v.target, false , nil, 10)
					Cmd_Attack(victimgroup, l_entityConcentration)
				
				elseif EGroup_IsEmpty(l_entityConcentration) == true then
				
					local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
					
					
					l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
					
					
					if SGroup_IsEmpty(l_humanConcentration) == false then
								
						
						--Cmd_Attack(victimgroup, l_humanConcentration)
						
						if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
							
								-- one in 3 chance of grenade attack!
							local l_randomattacktype = World_GetRand(1, 2)
									
--~ 							if l_randomattacktype == 1 then
--~ 							
--~ 									
--~ 								GrenadeBehaviour(victimgroup, victimtable, l_humanConcentration)	
--~ 									
--~ 							else
								
								victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_humanConcentration)
								
--~ 							end
						
						end
			
							
					end
				
				end
				
				
			end
			
		end
	end
end


function Creep_FlamerBehaviour(victimgroup, victimtable)

	if SGroup_IsIdle(victimgroup, ANY) then
		
		local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
		
				
		l_entityConcentration = Rule_GetPlayerEntityConcentration(l_entityConcentration)
		
		
		if EGroup_IsEmpty(l_entityConcentration) == false then
					
			--Cmd_AttackMove(v.name, v.target, false , nil, 10)
			Cmd_Attack(victimgroup, l_entityConcentration)
					
		elseif EGroup_IsEmpty(l_entityConcentration) == true then
		
 			local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
			
			
			l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
			
			
			if SGroup_IsEmpty(l_humanConcentration) == false then
				--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
				if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.ALL.Attack, l_humanConcentration)		
					
				end
				
			elseif SGroup_IsEmpty(l_humanConcentration) == true then
			
				for i = 1, table.getn(t_TargetTable) do
				
					if t_TargetTable[i].destroyed == false then
						--print(i)
						
				
					--	g_CreepObjective = t_TargetTable[i].name -- records the current default target as the unit's current target
						victimtable.defaulttarget = t_TargetTable[i].name -- records the current default target as the unit's current target
						
						break	
					end
				
				end
				
			end
			
		end
		
	elseif SGroup_IsIdle(victimgroup, ANY) == false then
	
		if SGroup_IsUnderAttack(victimgroup, ANY, 5) then
		
			local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_IsEmpty(l_lastattacker) == false then
				
				if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
				else
			
					if SGroup_IsEmpty(l_lastattacker) == false then
							
						--Cmd_Attack(victimgroup, l_lastattacker)
						Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
						--Cmd_Move(victimgroup, l_lastattacker, nil, nil, nil, nil, 40, 40)
						
						victimtable.attacker = l_lastattacker
						
						SGroup_Clear(l_lastattacker)
						
					end
					
				end

				
--~ 				--Cmd_Attack(victimgroup, l_lastattacker)
--~ 				Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
--~ 				
--~ 				SGroup_Clear(l_lastattacker)
			else
				for i = 1, table.getn(t_TargetTable) do
					
					if t_TargetTable[i].destroyed == false then
					--print(i)
						
				
						--g_CreepObjective = t_TargetTable[i].name -- records the current default target as the unit's current target
						victimtable.defaulttarget = t_TargetTable[i].name -- records the current default target as the unit's current target
						
						break	
					end
					
				end
				
				victimtable.target = victimtable.defaulttarget -- records the current default target as the unit's current target
				
				Cmd_Attack(victimgroup, victimtable.target)

				
			end
			
		end
		
	end
	

end



function Creep_BuildingBehaviour(victimgroup, index, victimtable)

	if SGroup_IsUnderAttack(victimgroup, ANY, 10) and ((SGroup_IsEmpty(sg_CreepOverGroup) == false) and (SGroup_TotalMembersCount(sg_CreepOverGroup) >= 15)) then 
		--print("1111")
		
		--*******************index should actually indicate current target's buildings
		--local randombuildingnumber = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals[index].garrisonbuildings))
		--local buildingtogarrison = t_SpawnLocationsAndGoals[index].garrisonbuildings[randombuildingnumber]
		
		local buildingtogarrison = t_SpawnLocationsAndGoals[index].garrisonbuildings[1]
		if EGroup_IsEmpty(buildingtogarrison) == false and EGroup_IsHoldingAny(buildingtogarrison) == false then
			
			Cmd_Garrison(victimgroup, buildingtogarrison, true)
			
		end
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_IsEmpty(l_lastattacker) == false then
					
				--Cmd_Attack(victimgroup, l_lastattacker)
				--Cmd_Attack(victimgroup, l_lastattacker, nil, nil, 35)
				Cmd_Move(victimgroup, l_lastattacker, nil, nil, nil, nil, 40, 40)
				
				SGroup_Clear(l_lastattacker)
				
			end
			
		end
			
	elseif (SGroup_IsUnderAttack(victimgroup, ANY, 10) == false) or (SGroup_IsUnderAttack(victimgroup, ANY, 10) and (SGroup_IsEmpty(sg_CreepOverGroup) == false) and (SGroup_TotalMembersCount(sg_CreepOverGroup) < 15)) then
		
		local stillingarrison = false
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			Cmd_UngarrisonSquad(victimgroup)
			
		end
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			stillingarrison = true
			
		end
		
		if stillingarrison == false then
		
			-- if the over group is under attack
			if SGroup_IsEmpty(sg_CreepOverGroup) == false and SGroup_IsUnderAttack(sg_CreepOverGroup, ANY, 2) 
					and (SGroup_IsUnderAttack(victimgroup, ANY, 2) == false) then
					
					
			--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
				if SGroup_IsEmpty(victimtable.attacker) then
					
					local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
					
					SGroup_GetLastAttacker(sg_CreepOverGroup, l_lastattacker)
					
					if SGroup_Compare(l_lastattacker, victimtable.attacker) then
					
					
					else
					
						if SGroup_IsEmpty(l_lastattacker) == false then
								
							if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
							--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
							
								local l_randomattacktype = World_GetRand(1, 2)
										
								if l_randomattacktype == 1 then
								
									
								
									GrenadeBehaviour(victimgroup, victimtable, l_lastattacker)	
									
								else
									victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.UngarrisonAndAttack, l_lastattacker)
									
								end
								
							end
							
							victimtable.attacker = l_lastattacker
							
							SGroup_Clear(l_lastattacker)
							
						end
						
					end
					
				elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
						
						-- one in 3 chance of grenade attack!
							local l_randomattacktype = World_GetRand(1, 2)
									
							if l_randomattacktype == 1 then
							
								
							
								GrenadeBehaviour(victimgroup, victimtable, victimtable.attacker)	
								
							else
								
								victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, victimtable.attacker)
								
							end
						
					end
				
				
				end	
				
			-- if the squad is idle, then attack the nearest concentration of enemy squads
			elseif SGroup_IsIdle(victimgroup, ANY) then
				print("idle!")
			
				local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
				
				l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)

				if SGroup_IsEmpty(l_humanConcentration) == false then
						
					--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
					
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
					
						local l_randomattacktype = World_GetRand(1, 2)
									
						if l_randomattacktype == 1 then
						
							GrenadeBehaviour(victimgroup, victimtable, l_humanConcentration)	
							
						else
						
											
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.UngarrisonAndAttack, l_humanConcentration)
						
						end
					
					end
						
				elseif SGroup_IsEmpty(l_humanConcentration) == true then
				
					Cmd_AttackMove(victimgroup, mkr_KamikazeDestination, nil, nil, 30)
				
					--Cmd_Move(victimgroup, victimgroup, nil, nil, nil, nil, nil, 50)	
				
				end
			
			end
			
			
		end
		
	end

end



function Creep_SniperBehaviour(victimgroup, index, victimtable)

	if SGroup_IsUnderAttack(victimgroup, ANY, 5) then 
		
		--local randombuildingnumber = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals[index].garrisonbuildings))
		--local buildingtogarrison = t_SpawnLocationsAndGoals[index].garrisonbuildings[randombuildingnumber]
		
		local buildingtogarrison = t_SpawnLocationsAndGoals[index].garrisonbuildings[2]
		if EGroup_IsEmpty(buildingtogarrison) == false and EGroup_IsHoldingAny(buildingtogarrison) == false then
			
			Cmd_Garrison(victimgroup, buildingtogarrison, true)
			
		end
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_IsEmpty(l_lastattacker) == false then
					
				--Cmd_Attack(victimgroup, l_lastattacker)
				--Cmd_Attack(victimgroup, l_lastattacker, nil, nil, 35)
				Cmd_Move(victimgroup, l_lastattacker, nil, nil, nil, nil, 40, 40)
				
				SGroup_Clear(l_lastattacker)
				
			end
			
		end
			
	elseif (SGroup_IsUnderAttack(victimgroup, ANY, 25) == false) then
		
		local stillingarrison = false
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			Cmd_UngarrisonSquad(victimgroup)
			
		end
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			stillingarrison = true
			
		end
		
		if stillingarrison == false then
		
		
			local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
			
						
			l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
			
			if SGroup_IsEmpty(l_humanConcentration) == false then
						
				
				--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
				if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
					
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_humanConcentration)
				
				end
						
			elseif SGroup_IsEmpty(l_humanConcentration) == true then
			
				Cmd_AttackMove(victimgroup, mkr_KamikazeDestination, nil, nil, 40)
--~ 				local buildingConcentration = Player_GetEntityConcentration(g_HumanPlayer)
--~ 				
--~ 				if EGroup_IsEmpty(buildingConcentration) == true then
--~ 				
--~ 					if EGroup_IsEmpty(currenttarget) == true then -- if this squad's target is destroyed then attack the default current target
--~ 							
--~ 						currenttarget = defaulttarget -- records the current default target as the unit's current target
--~ 							
--~ 						--Cmd_AttackMove(victimgroup, currenttarget, false , nil, 10)
--~ 						Cmd_Attack(victimgroup, currenttarget)
--~ 						
--~ 					end
--~ 					
--~ 				else
--~ 					currenttarget = buildingConcentration -- records the current default target as the unit's current target
--~ 				
--~ 					Cmd_Attack(victimgroup, currenttarget)
--~ 				
--~ 				end
				
			end
		

		end
		
	end

end

function Creep_LMGBehaviour(victimgroup, victimtable)

	local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
	-- if the squad is under attack
	if SGroup_IsUnderAttack(victimgroup, ANY, 2) then 
		
		--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
			else
			
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					--Cmd_Attack(victimgroup, l_lastattacker)
					Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					--Cmd_Move(victimgroup, l_lastattacker, nil, nil, nil, nil, 40, 40)
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		end
						
		-- if the squad is idle, then find someone to attack
	elseif SGroup_IsIdle(victimgroup, ANY) then
	
		local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
			
		
		l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
		
			if SGroup_IsEmpty(l_humanConcentration) == false then
				
				--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
				if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_humanConcentration)
				
				end
				
				
						
			elseif SGroup_IsEmpty(l_humanConcentration) == true then
			
				Cmd_AttackMove(victimgroup, mkr_KamikazeDestination, nil, nil, 40)
	
			end
		
	end


end



function Creep_DemoBehaviour(victimgroup, victimtable)

	
		if EGroup_IsEmpty(victimtable.target) == false then
		
			if Prox_EGroupSGroup(victimtable.target, victimgroup, PROX_SHORTEST) > 30 then
			
				--Cmd_AttackMove(victimgroup, currenttarget, false , nil, 40)
				Cmd_Move(victimgroup, victimtable.target, false , nil, nil, nil, 30, 30)
			elseif Prox_EGroupSGroup(victimtable.target, victimgroup, PROX_SHORTEST) <= 30 then
			
			
				Cmd_Attack(victimgroup, victimtable.target)
				
			--Cmd_AttackMove(victimgroup, currenttarget, false , nil, 40)
			
			end
		
		else 
			if SGroup_IsIdle(victimgroup, ANY) then
		
				if g_LastBuildingDestroyed == false then
				
				
					if EGroup_IsEmpty(victimtable.target) == true then -- if this squad's target is destroyed then attack the default current target
						
						
						for i = 1, table.getn(t_TargetTable) do
							
							if t_TargetTable[i].destroyed == false then
							--print(i)
						
						
								--g_CreepObjective = t_TargetTable[i].name -- records the current default target as the unit's current target
								victimtable.defaulttarget = t_TargetTable[i].name -- records the current default target as the unit's current target
								
								break	
							end
							
						end
						
						victimtable.target = victimtable.defaulttarget -- records the current default target as the unit's current target
						
						Cmd_Attack(victimgroup, victimtable.target)
						
					else
					
						Cmd_Attack(victimgroup, victimtable.target)
					
					end
					
				elseif g_LastBuildingDestroyed == true then
					
					local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
					
					l_entityConcentration = Rule_GetPlayerEntityConcentration(l_entityConcentration)
					
					if EGroup_IsEmpty(l_entityConcentration) == false then
					
						
						Cmd_Attack(victimgroup, l_entityConcentration)
						
					elseif EGroup_IsEmpty(l_entityConcentration) == true then
					
						local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
						
						l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)

						if SGroup_IsEmpty(l_humanConcentration) == false then
									
							
							--Cmd_Attack(victimgroup, l_humanConcentration)
							if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
					
						-- one in 3 chance of grenade attack!
								local l_randomattacktype = World_GetRand(1, 2)
										
								if l_randomattacktype == 1 then
								
										
									GrenadeBehaviour(victimgroup, victimtable, l_humanConcentration)	
										
								else
									
									victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_humanConcentration)
									
								end
							
							end
			
								
						end
					
					end
					
					
				end
				
			end
		end
	--end
end





function Creep_EscortBehaviour(victimgroup, victimtable)

	local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
	-- if the vehicle group is under attack
	if SGroup_IsEmpty(victimtable.vehicletoescort) == false and SGroup_IsUnderAttack(victimtable.vehicletoescort, ANY, 2) 
			and (SGroup_IsUnderAttack(victimgroup, ANY, 2) == false) then
			
			
	--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimtable.vehicletoescort, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
				
				
			else
				
				if SGroup_IsEmpty(l_lastattacker) == false then
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
						
						-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 2)
								
						if l_randomattacktype == 1 then
							
							GrenadeBehaviour(victimgroup, victimtable, l_lastattacker)	
							
						else
							
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_lastattacker)
							
						end
						
					end
					
					
					
					victimgroup.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
				local l_randomattacktype = World_GetRand(1, 2)
				
				if l_randomattacktype == 1 then
					
					
					
					GrenadeBehaviour(victimgroup, victimtable, victimtable.attacker)	
					
				else
					
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, victimtable.attacker)
					
				end
				
			end
			
		end		
		
	-- if the squad is under attack
	elseif SGroup_IsUnderAttack(victimgroup, ANY, 2) then 
		
		--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			else
				
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
							
						-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 2)
						
						if l_randomattacktype == 1 then
							
							GrenadeBehaviour(victimgroup, victimtable, l_lastattacker)
							
						else
							
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_lastattacker)
							
						end
						
					end
					
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
			
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
				local l_randomattacktype = World_GetRand(1, 2)
				
				if l_randomattacktype == 1 then
					
					GrenadeBehaviour(victimgroup, victimtable, victimtable.attacker)	
					
				else
					
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, victimtable.attacker)
					
				end
			
			end
			
		end		
	-- if no vehicle to escort then	
	elseif SGroup_IsEmpty(victimtable.vehicletoescort) == true then
		
		victimtable.role = t_RoleType[2] -- change role type to heavy
		
		
	-- if the squad is idle, then attack the targets everything else is attacking
	else --if SGroup_IsIdle(victimgroup, ANY) then
		
		if SGroup_IsEmpty(victimtable.vehicletoescort) == false then
			
			Cmd_Move(victimgroup, victimtable.vehicletoescort, nil, nil, nil, nil, nil, 50)	
			
		elseif SGroup_IsEmpty(sg_CreepOverGroup) == false then
			
			Cmd_Move(victimgroup, sg_CreepOverGroup, nil, nil, nil, nil, nil, 50)	
			
		end
		
	end
end







function Creep_RepairBehaviour(victimgroup, victimtable)
--print("repairing?")
	local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
	-- if the vehicle group is under attack
	if SGroup_IsEmpty(victimtable.vehicletoescort) == false and SGroup_GetAvgHealth(victimtable.vehicletoescort) < 0.65 then
		
		Cmd_Ability(victimgroup, ABILITY.REPAIR, victimtable.vehicletoescort, nil, false)
		
		
	-- if the squad is under attack
	elseif SGroup_IsUnderAttack(victimgroup, ANY, 2) then 
		
		--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			else
				
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					--Cmd_Attack(victimgroup, l_lastattacker)
					Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					--Cmd_Move(victimgroup, l_lastattacker, nil, nil, nil, nil, 40, 40)
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		end			
	-- if no vehicle to escort then	
	elseif SGroup_IsEmpty(victimtable.vehicletoescort) == true then
		
		if table.getn(t_VehicleInfo) > 0 then -- if there are vehicles in the vehicle squad table then
			
			for i = 1, table.getn(t_VehicleInfo) do
				
				if SGroup_IsEmpty(t_VehicleInfo[i].name) == false then -- check to see if vehicle squad is empty
					
					victimtable.vehicletoescort = t_VehicleInfo[i].name -- if not, then assign this vehicle to escort
					
					break -- as soon as vehicle found, break out of this for loop
					
				end
				
			end
			
		else -- if there are no vehicles left in the vehicle squad table then
			
			-- find greatest concentration of human units
			local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
				
				
			l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
			
			-- if the player units exist then attack
			if SGroup_IsEmpty(l_humanConcentration) == false then
				
				Cmd_AttackMove(victimgroup, l_humanConcentration, nil, nil, 40)
							
			else -- else, look for player buildings
							
				local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
								
				l_entityConcentration = Rule_GetPlayerEntityConcentration(l_entityConcentration)
				
			end
		end
	
		
	-- if the squad is idle, then attack the targets everything else is attacking
	else --if SGroup_IsIdle(victimgroup, ANY) then
	
		if SGroup_IsEmpty(victimtable.vehicletoescort) == false then
	
			Cmd_Move(victimgroup, victimtable.vehicletoescort, nil, nil, nil, nil, nil, 50)	
	
		elseif SGroup_IsEmpty(sg_CreepOverGroup) == false then
	
			Cmd_Move(victimgroup, sg_CreepOverGroup, nil, nil, nil, nil, nil, 50)	
		
		end
	
	end
end






function Creep_NebelBehaviour(victimgroup, victimtable)

	local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
	local l_t_nebelattack = {{g_Actor, 10000028},}	-- incoming rocket attack warning
					
	l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
	
	if SGroup_IsEmpty(l_humanConcentration) == false and SGroup_IsEmpty(sg_CreepOverGroup) == false then

			
		--Cmd_AttackMove(v.name, v.target, false , nil, 10)
		Cmd_Ability(victimgroup, ABILITY.AXIS.NEB_BARRAGE, l_humanConcentration, nil, false)
		

		if SGroup_IsDoingAbility(victimgroup, ABILITY.AXIS.NEB_BARRAGE, ALL) == true and g_NebelDialogueCooldown <= 0 then
		
			local l_speechpath = soundData.miscwarning.rocket
			PlayInvasionSpeech(Game_GetLocalPlayer(), l_speechpath)
			
			
			Nebel_Ping_ID = UI_CreateMinimapBlip(victimgroup, 10, BT_AttackHerePing)
			
			g_NebelDialogueCooldown = 6
		
		else
		
			g_NebelDialogueCooldown = g_NebelDialogueCooldown - 1
	
		end
		
	elseif SGroup_IsEmpty(l_humanConcentration) == true or (SGroup_IsEmpty(sg_CreepOverGroup) or SGroup_TotalMembersCount(sg_CreepOverGroup) <= 15) then
	
		--Cmd_AttackMove(victimgroup, mkr_KamikazeDestination, nil, nil, 30)
		
		local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
		l_entityConcentration = Rule_GetPlayerEntityConcentration_Rocket(l_entityConcentration)
		
		if EGroup_IsEmpty(l_entityConcentration) == false then
			
			if EGroup_ContainsBlueprints(l_entityConcentration, {EBP.SP.ALLY_2ND_MOTORPOOL_INVASION, EBP.SP.AXIS_COMMAND_INVASION}, ANY) then
				
				--EGroup_Filter(l_entityConcentration, {EBP.SP.ALLY_2ND_MOTORPOOL_INVASION, EBP.SP.AXIS_COMMAND_INVASION}, FILTER_REMOVE)
				
			end
			
			if EGroup_IsEmpty(l_entityConcentration) == false then
				
				if SGroup_IsDoingAbility(victimgroup, ABILITY.AXIS.NEB_BARRAGE, ALL) == false then
			
					Cmd_Ability(victimgroup, ABILITY.AXIS.NEB_BARRAGE, Entity_GetPosition(EGroup_GetRandomSpawnedEntity(l_entityConcentration)), nil, false)
					EGroup_Clear(l_entityConcentration)
				else				
			
					if SGroup_IsDoingAbility(victimgroup, ABILITY.AXIS.NEB_BARRAGE, ALL) == true and g_NebelDialogueCooldown <= 0 then
			
						--Util_AutoIntel(l_t_calliopeattack)
						
						local l_speechpath = soundData.miscwarning.rocket
						PlayInvasionSpeech(Game_GetLocalPlayer(), l_speechpath)
						
						Calliope_Ping_ID = UI_CreateMinimapBlip(victimgroup, 10, BT_AttackHerePing)
						
						g_NebelDialogueCooldown = 6
						
					else
						
						g_NebelDialogueCooldown = g_NebelDialogueCooldown - 1
						
					end
					
				end
				
			else
				
			end
			
		else
			
		end
		
	end

end




function Creep_HMGBehaviour(victimgroup, index, victimtable)

	if SGroup_IsUnderAttack(victimgroup, ALL, 25) then 
		
		local l_randommove = World_GetRand(1, 2)
		
		
		
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) == false then
		

			local buildingtogarrison = EGroup_CreateIfNotFound("buildingtogarrison")
		
			local buildingtogarrisonentity = Util_GarrisonNearbyBuilding(victimgroup, SGroup_GetPosition(victimgroup), 40)
		
			-- implied that buildingtogarrisonentity is not nil
			if buildingtogarrisonentity then
			
				EGroup_Add(buildingtogarrison, buildingtogarrisonentity)
				
				if buildingtogarrison ~= nil and EGroup_IsEmpty(buildingtogarrison) == false and EGroup_IsHoldingAny(buildingtogarrison) == false then
				
					if EGroup_ContainsBlueprints(buildingtogarrison, {EBP.SP.BANK_INVASION, EBP.SP.MANOR_INVASION, EBP.SP.GARAGE_INVASION, EBP.SP.CHURCH_INVASION}, ANY) == false then
					
						Cmd_Garrison(victimgroup, buildingtogarrison, true)
					
					end
				
				end
			
				EGroup_Clear(buildingtogarrison)
				
			end
		
		elseif SGroup_IsInHoldEntity(victimgroup, ANY) == true then
		
		
			local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_IsEmpty(l_lastattacker) == false then
					
				Cmd_Attack(victimgroup, l_lastattacker)
				--Cmd_Attack(victimgroup, l_lastattacker, nil, nil, 35)
				--Cmd_Move(victimgroup, l_lastattacker, nil, nil, nil, nil, 40, 40)
				
				SGroup_Clear(l_lastattacker)
				
			end
		
		
			
		end
		
	elseif (SGroup_IsUnderAttack(victimgroup, ANY, 25) == false) then
		
		local stillingarrison = false
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			Cmd_UngarrisonSquad(victimgroup)
			
		end
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			stillingarrison = true
			
		end
		
		if stillingarrison == false then
		
			-- if the over group is under attack
			if SGroup_IsEmpty(sg_CreepOverGroup) == false and SGroup_IsUnderAttack(sg_CreepOverGroup, ANY, 2) 
					and (SGroup_IsUnderAttack(victimgroup, ANY, 2) == false) then
					
					
			--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
				if SGroup_IsEmpty(victimtable.attacker) then
					
					local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
					
					SGroup_GetLastAttacker(sg_CreepOverGroup, l_lastattacker)
					
					if SGroup_Compare(l_lastattacker, victimtable.attacker) then
					
					
					else
					
						if SGroup_IsEmpty(l_lastattacker) == false then
								
							--Cmd_Attack(victimgroup, l_lastattacker)
							Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
							--Cmd_Move(victimgroup, l_lastattacker, nil, nil, nil, nil, 40, 40)
							
							victimtable.attacker = l_lastattacker
							
							SGroup_Clear(l_lastattacker)
							
						end
						
					end
					
				end			
				
			-- if the squad is idle, then attack the nearest concentration of enemy squads
			elseif SGroup_IsIdle(victimgroup, ANY) then
				print("idle!")
			
				local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
				
				l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)

				if SGroup_IsEmpty(l_humanConcentration) == false then
					
					--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
					
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
					
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_humanConcentration)
					
					end
						
				elseif SGroup_IsEmpty(l_humanConcentration) == true then
				
					Cmd_AttackMove(victimgroup, mkr_KamikazeDestination, nil, nil, 30)
				
					--Cmd_Move(victimgroup, victimgroup, nil, nil, nil, nil, nil, 50)	
				
				end
			
			end
			
			
		end
		
	end

end





function Creep_MortarBehaviour(victimgroup, victimtable)

	local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
	
	local l_t_mortarattack = {{g_Actor, 10000031},}	-- incoming mortar attack warning
					
	l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
		
		if SGroup_IsEmpty(l_humanConcentration) == false then
			
			-- if enemy mortars exist, humanConcentration will only contain the mortars, for priority.
			if SGroup_ContainsBlueprints(l_humanConcentration, SBP.ALLIES.MORTAR, ANY) then
			
				
				SGroup_Filter(l_humanConcentration, SBP.ALLIES.MORTAR, FILTER_KEEP)
				
			elseif SGroup_ContainsBlueprints(l_humanConcentration, SBP.AXIS.MORTAR, ANY) then

				SGroup_Filter(l_humanConcentration, SBP.AXIS.MORTAR, FILTER_KEEP)
			
			end
			
			-- player's mortars will now attack humanConcentration
			if SGroup_ContainsBlueprints(victimgroup, SBP.ALLIES.MORTAR, ANY) and SGroup_IsDoingAbility(victimgroup, ABILITY.ALLIES.MORTAR_BARRAGE, ALL) == false then
			
				Cmd_Ability(victimgroup, ABILITY.ALLIES.MORTAR_BARRAGE, Squad_GetPosition(SGroup_GetRandomSpawnedSquad(l_humanConcentration)), nil, false) --SGroup_GetPosition(l_humanConcentration)
				--Cmd_Attack(victimgroup, humanConcentration)
						
			elseif SGroup_ContainsBlueprints(victimgroup, SBP.AXIS.MORTAR, ANY) and SGroup_IsDoingAbility(victimgroup, ABILITY.AXIS.MORTAR_BARRAGE, ALL) == false then
			
				Cmd_Ability(victimgroup, ABILITY.AXIS.MORTAR_BARRAGE, Squad_GetPosition(SGroup_GetRandomSpawnedSquad(l_humanConcentration)), nil, false)
				--Cmd_Attack(victimgroup, humanConcentration)
			
			end
			
			if (SGroup_IsDoingAbility(victimgroup, ABILITY.ALLIES.MORTAR_BARRAGE, ALL) == true or SGroup_IsDoingAbility(victimgroup, ABILITY.ALLIES.MORTAR_BARRAGE, ALL) == true) and g_MortarDialogueCooldown <= 0 then
				
				--Util_AutoIntel(l_t_mortarattack)
				
				local l_speechpath = soundData.miscwarning.mortar
				PlayInvasionSpeech(Game_GetLocalPlayer(), l_speechpath)
				
				Mortar_Ping_ID = UI_CreateMinimapBlip(victimgroup, 10, BT_AttackHerePing)
				
				g_MortarDialogueCooldown = 6
				
			else
				
				g_MortarDialogueCooldown = g_MortarDialogueCooldown - 1
				
			end
				
			
		elseif SGroup_IsEmpty(l_humanConcentration) == true then
		
--~ 			local random_entity = World_GetRand(1, table.getn(teg_StuffSpawn))
--~ 			
--~ 			if EGroup_IsEmpty(teg_StuffSpawn[random_entity]) == false then

--~ 				Cmd_Attack(victimgroup, teg_StuffSpawn[random_entity])

--~ 			end
			
			
		
		end
		


end
	

	

function Creep_VehicleEscortBehaviour(victimgroup, victimtable)

	local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
	
	-- if the vehicle group is under attack
	if SGroup_IsEmpty(victimtable.vehicletoescort) == false and SGroup_IsUnderAttack(victimtable.vehicletoescort, ANY, 2) 
			and (SGroup_IsUnderAttack(victimgroup, ANY, 2) == false) then
			
			
	--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimtable.vehicletoescort, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
			else
			
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
					local l_randomattacktype = World_GetRand(1, 3)
					
						if l_randomattacktype == 1 then
						
						
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankLeftFront, l_lastattacker)
						
						elseif l_randomattacktype ==2 then
						
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankRightFront, l_lastattacker)
							
						elseif l_randomattacktype ==3 then
						
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.MaximizeRange, l_lastattacker)
					
						end
						
					end
					
					victimgroup.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
			if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
				
							
				local l_randomattacktype = World_GetRand(1, 3)
					
				if l_randomattacktype == 1 then
					
						
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankLeftFront, victimtable.attacker)
						
				elseif l_randomattacktype ==2 then
						
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankRightFront, victimtable.attacker)
							
				elseif l_randomattacktype ==3 then
						
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.MaximizeRange, victimtable.attacker)
					
				end
				
			end
		
		
		end		
		
	-- if the squad is under attack
	elseif SGroup_IsUnderAttack(victimgroup, ANY, 2) then 
	
		--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			else
				
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					
					--Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
							
								-- one in 3 chance of grenade attack!
						local l_randomattacktype = World_GetRand(1, 3)
					
						if l_randomattacktype == 1 then
							
								
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankLeftFront, l_lastattacker)
								
						elseif l_randomattacktype ==2 then
								
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankRightFront, l_lastattacker)
									
						elseif l_randomattacktype ==3 then
								
							victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.MaximizeRange, l_lastattacker)
							
						end
						
					end
					
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
			
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
				if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
				
				-- one in 3 chance of grenade attack!
					local l_randomattacktype = World_GetRand(1, 3)
					
					if l_randomattacktype == 1 then
						
							
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankLeftFront, l_lastattacker)
							
					elseif l_randomattacktype ==2 then
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.FlankRightFront, l_lastattacker)
						
					elseif l_randomattacktype ==3 then
						
						victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.VEHICLE.MaximizeRange, l_lastattacker)
						
					end
						
				
				end
		
		
		end		
				
	-- if no vehicle to escort then	turn into a regular vehicle type
	elseif (SGroup_IsEmpty(victimtable.vehicletoescort) == true or (SGroup_IsEmpty(victimtable.vehicletoescort) == false and SGroup_Compare(victimtable.vehicletoescort, victimgroup) == true))
		and victimtable.role ~= t_RoleType[3] then
		
		victimtable.role = t_RoleType[3] -- change role type to vehicle
	
		return
	-- if the squad is idle, move the tank to follow the escort vehicle
	elseif SGroup_IsIdle(victimgroup, ANY) then
			
		if SGroup_IsEmpty(victimtable.vehicletoescort) == false and SGroup_IsMoving(victimgroup, ANY) == false then
		
			Cmd_Move(victimgroup, SGroup_GetPosition(victimtable.vehicletoescort), nil, nil, nil, OFFSET_BACK, 10 )	
	
		end
	
	end
end




function Creep_ATBehaviour(victimgroup, victimtable)


	local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
	-- if the squad is under attack
	if SGroup_IsUnderAttack(victimgroup, ANY, 2) then 
		
		--if SGroup_IsIdle(victimgroup, ANY) then	-- prevents enemies from looping around between attackers
		if SGroup_IsEmpty(victimtable.attacker) then
			
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_Compare(l_lastattacker, victimtable.attacker) then
			
			
			else
			
				if SGroup_IsEmpty(l_lastattacker) == false then
						
					
					Cmd_AttackMove(victimgroup, l_lastattacker, nil, nil, 35)
					
					victimtable.attacker = l_lastattacker
					
					SGroup_Clear(l_lastattacker)
					
				end
				
			end
		
		elseif SGroup_IsEmpty(victimtable.attacker) == false then
		
			Cmd_Attack(victimgroup, victimtable.attacker)
		
		end


		-- if the squad is idle, then attack the targets everything else is attacking
	elseif SGroup_IsIdle(victimgroup, ANY) then
	
	
		if EGroup_IsEmpty(victimtable.target) == false then
			
			--Cmd_AttackMove(victimgroup, v.target, false , nil, 10)
			Cmd_Attack(victimgroup, victimtable.target)
			
		elseif EGroup_IsEmpty(victimtable.target) == true then -- if this squad's target is destroyed then attack the default current target
			
			
			local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
		
				
			l_entityConcentration = Rule_GetPlayerEntityConcentration(l_entityConcentration)
				
				
			if EGroup_IsEmpty(l_entityConcentration) == false then
							
				--Cmd_AttackMove(v.name, v.target, false , nil, 10)
				Cmd_Attack(victimgroup, l_entityConcentration)
			else
			
				local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
				
				
				l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
				
				
				if SGroup_IsEmpty(l_humanConcentration) == false then
					
					Cmd_AttackMove(victimgroup, l_humanConcentration, false , nil, 30)
					
					
			
				end
			end	
		end
		
	end


end

function Creep_CamoSniperBehaviour(victimgroup, index, victimtable)

	if SGroup_IsUnderAttack(victimgroup, ANY, 5) then 
		
		--local randombuildingnumber = World_GetRand(1, table.getn(t_SpawnLocationsAndGoals[index].garrisonbuildings))
		--local buildingtogarrison = t_SpawnLocationsAndGoals[index].garrisonbuildings[randombuildingnumber]
		
		local buildingtogarrison = t_SpawnLocationsAndGoals[index].garrisonbuildings[2]
		if EGroup_IsEmpty(buildingtogarrison) == false and EGroup_IsHoldingAny(buildingtogarrison) == false then
			
			Cmd_Garrison(victimgroup, buildingtogarrison, true)
			
		end
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			local l_lastattacker = SGroup_CreateIfNotFound("l_lastattacker")
		
			SGroup_GetLastAttacker(victimgroup, l_lastattacker)
			
			if SGroup_IsEmpty(l_lastattacker) == false then
				
				Cmd_Move(victimgroup, l_lastattacker, nil, nil, nil, nil, 40, 40)
				
				SGroup_Clear(l_lastattacker)
				
			end
			
		end
			
	elseif (SGroup_IsUnderAttack(victimgroup, ANY, 15) == false) then
		
		local stillingarrison = false
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			Cmd_UngarrisonSquad(victimgroup)
			
		end
		
		if SGroup_IsInHoldEntity(victimgroup, ANY) then
		
			stillingarrison = true
			
		end
		
		if stillingarrison == false then
		
		
			local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
			
						
			l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
				
			if SGroup_IsEmpty(l_humanConcentration) == false then
				
				--Cmd_AttackMove(victimgroup, humanConcentration, false , nil, 30)
				if CombatPlan_IsExecuting(victimtable.combatPlan) == false then
					
					if SGroup_IsDoingAbility(victimgroup, ABILITY.COHO.UMS.INVASION.CAMOUFLAGE_TOGGLE, ANY) == false then
						
						Cmd_Ability(victimgroup, ABILITY.COHO.UMS.INVASION.CAMOUFLAGE_TOGGLE, nil, nil, false) -- to activate camo
						
					end
					
					victimtable.combatPlan = CombatPlan_Add(victimgroup, COMBAT_PLAN.GENERIC.INFANTRY.FindCoverAndAttack, l_humanConcentration)
					
				end
				
			elseif SGroup_IsEmpty(l_humanConcentration) == true then
				
				if SGroup_IsDoingAbility(victimgroup, ABILITY.COHO.UMS.INVASION.CAMOUFLAGE_TOGGLE, ANY) == true then
				
					Cmd_Ability(victimgroup, ABILITY.COHO.UMS.INVASION.CAMOUFLAGE_TOGGLE, nil, nil, false) -- to deactivate camo
					
				end
				
				Cmd_AttackMove(victimgroup, mkr_KamikazeDestination, nil, nil, 40)
				
			end
			
		end
		
	end

end

function Creep_CalliopeBehaviour(victimgroup, victimtable)
	
	local l_humanConcentration = Player_GetSquadConcentration(t_PlayerHumanInfo[1].playerID)
	local l_t_calliopeattack = {{g_Actor, 10000028},}	-- incoming rocket attack warning
	
	l_humanConcentration = Rule_GetPlayerUnitConcentration(l_humanConcentration)
	
	if SGroup_IsEmpty(l_humanConcentration) == false and SGroup_IsEmpty(sg_CreepOverGroup) == false then
		
		
		if SGroup_IsDoingAbility(victimgroup, ABILITY.COHO.UMS.INVASION.CALLIOPE_ARMOUR, ALL) == false then
			
			Cmd_Ability(victimgroup, ABILITY.COHO.UMS.INVASION.CALLIOPE_ARMOUR, Squad_GetPosition(SGroup_GetRandomSpawnedSquad(l_humanConcentration)), nil, false) --SGroup_GetPosition(l_humanConcentration)
			SGroup_Clear(l_humanConcentration)
		end
		
		if SGroup_IsDoingAbility(victimgroup, ABILITY.COHO.UMS.INVASION.CALLIOPE_ARMOUR, ALL) == true and g_CalliopeDialogueCooldown <= 0 then
			
			local l_speechpath = soundData.miscwarning.rocket
			PlayInvasionSpeech(Game_GetLocalPlayer(), l_speechpath)
			
			Calliope_Ping_ID = UI_CreateMinimapBlip(victimgroup, 10, BT_AttackHerePing)
			
			g_CalliopeDialogueCooldown = 6
			
		else
			
			g_CalliopeDialogueCooldown = g_CalliopeDialogueCooldown - 1
			
		end
		
	elseif SGroup_IsEmpty(l_humanConcentration) == true or (SGroup_IsEmpty(sg_CreepOverGroup) or SGroup_TotalMembersCount(sg_CreepOverGroup) <= 15) then
		
		local l_entityConcentration = Player_GetEntityConcentration(t_PlayerHumanInfo[1].playerID)
		l_entityConcentration = Rule_GetPlayerEntityConcentration_Rocket(l_entityConcentration)
		
		if EGroup_IsEmpty(l_entityConcentration) == false then
			
			if EGroup_ContainsBlueprints(l_entityConcentration, {EBP.SP.ALLY_2ND_MOTORPOOL_INVASION, EBP.SP.AXIS_COMMAND_INVASION}, ANY) then
				
				--EGroup_Filter(l_entityConcentration, {EBP.SP.ALLY_2ND_MOTORPOOL_INVASION, EBP.SP.AXIS_COMMAND_INVASION}, FILTER_REMOVE)
				
			end
			
			if EGroup_IsEmpty(l_entityConcentration) == false then
				
				if SGroup_IsDoingAbility(victimgroup, ABILITY.COHO.UMS.INVASION.CALLIOPE_ARMOUR, ALL) == false then
			
					Cmd_Ability(victimgroup, ABILITY.COHO.UMS.INVASION.CALLIOPE_ARMOUR, Entity_GetPosition(EGroup_GetRandomSpawnedEntity(l_entityConcentration)), nil, false)
					EGroup_Clear(l_entityConcentration)
				else				
			
					if SGroup_IsDoingAbility(victimgroup, ABILITY.COHO.UMS.INVASION.CALLIOPE_ARMOUR, ALL) == true and g_CalliopeDialogueCooldown <= 0 then
			
						--Util_AutoIntel(l_t_calliopeattack)
						
						local l_speechpath = soundData.miscwarning.rocket
						PlayInvasionSpeech(Game_GetLocalPlayer(), l_speechpath)
						
						Calliope_Ping_ID = UI_CreateMinimapBlip(victimgroup, 10, BT_AttackHerePing)
						
						g_CalliopeDialogueCooldown = 6
						
					else
						
						g_CalliopeDialogueCooldown = g_CalliopeDialogueCooldown - 1
						
					end
					
				end
				
			else
				
			end
			
		else
			
		end
	end

end


	
----------------------------
function GrenadeBehaviour(grenadetosser, grenadetossertable, target)
				
			local l_randomgrenadetype = World_GetRand(1, 3)
		
			local lt_alliesgrenadeplan = {COMBAT_PLAN.INVASION.ALLIES.GENERIC.ThrowGrenadeNoReqs, COMBAT_PLAN.INVASION.ALLIES.GENERIC.FlankLeftThrowGrenadeNoReqs, COMBAT_PLAN.INVASION.ALLIES.GENERIC.FlankRightThrowGrenadeNoReqs}
			local lt_axisgrenadeplan = {COMBAT_PLAN.INVASION.AXIS.GENERIC.ThrowGrenadeNoReqs, COMBAT_PLAN.INVASION.AXIS.GENERIC.FlankLeftThrowGrenadeNoReqs, COMBAT_PLAN.INVASION.AXIS.GENERIC.FlankRightThrowGrenadeNoReqs}
				
			if SGroup_ContainsBlueprints(grenadetosser, {SBP.ALLIES.RIFLEMEN, SBP.ALLIES.RANGER, SBP.ALLIES.PARATROOPER}, ANY) == true then
				
				grenadetossertable.combatPlan = CombatPlan_Add(grenadetosser, lt_alliesgrenadeplan[l_randomgrenadetype], target)
				
			elseif SGroup_ContainsBlueprints(grenadetosser, {SBP.AXIS.VOLKSGRENADIER, SBP.AXIS.GRENADIER, SBP.AXIS.STORMTROOPER}, ANY) == true then
			
				grenadetossertable.combatPlan = CombatPlan_Add(grenadetosser, lt_axisgrenadeplan[l_randomgrenadetype], target)
			
			end
	
	
end

--------------------------==

function WaveResourceBonus()
	
	local creepProgression = t_CreepWaveInfo[g_WaveProgression]
	
	-- Allies get fuel, but Axis will not
	
	for i = 1, table.getn(t_PlayerHumanInfo) do
		
		Player_AddResource(t_PlayerHumanInfo[i].playerID, RT_Manpower, creepProgression.resourceBonus) -- adds a resource bonus for surviving the wave
		Player_AddResource(t_PlayerHumanInfo[i].playerID, RT_Munition, 50)
		
		if Player_GetRaceName(Game_GetLocalPlayer()) == TRACE_ALLIES then
			
			Player_AddResource(t_PlayerHumanInfo[i].playerID, RT_Fuel, 50)
			
		end
		
	end
		
end


--------------------------==
-- grants the player resources per squad killed
-- we may use a different check so that we can customize the resources given depending on the type of unit that dies
function Creep_KillReward(squad)

	-- brw, this always grants "player1" the resources regardless of who killed it?
	-- what about team members?
	
	local ScoreMultiplier = 1 -- bonus multiplier for the player score
	local TypeMultiplier = 1 -- multiplier that changes according to enemy type, default is 1
	local TypeResourceBonus = 1 -- determines the amount of resources a player gets depending on unit type that died
	local TypeMunitionBonus = 1 -- determines the amount of resources a player gets depending on unit type that died
	local OverallScoreMultiplier = 10 --overall score adjuster
	
	for k, v in pairs(t_SpawnedUnitInfo) do
	
		if SGroup_GetAvgHealth(v.name) == 0 then
		
		
			local TempTime = World_GetGameTime()
			local TempDifference = TempTime - v.spawntime
		
			if TempDifference <= 20 then
			
				ScoreMultiplier = 5
			
			elseif TempDifference >= 21 and TempDifference <= 40 then
			
				ScoreMultiplier = 3
			
			elseif TempDifference >= 41 and TempDifference <= 60 then
			
				ScoreMultiplier = 1
			
			end
			
			if v.vehicle == true then
				-- Vehicles
				TypeMultiplier = 50 -- used to be 10
				TypeResourceBonus = math.floor(36 / table.getn(t_PlayerHumanInfo))  -- used to be 10 and 25
				TypeMunitionBonus = math.floor(12/ table.getn(t_PlayerHumanInfo))  -- used to be 10 and 25
			elseif v.vehicle == false then
				-- Infantry
				TypeMultiplier = 25 -- used to be 5
				TypeResourceBonus = math.floor(20 / table.getn(t_PlayerHumanInfo)) -- used to be 1 and 12
				TypeMunitionBonus = math.floor(4 / table.getn(t_PlayerHumanInfo))  -- used to be 10 and 25
			end
			
			--single player bonus
			
			if g_NumberOfHumans <= 1 then
			
				TypeResourceBonus = math.floor(TypeResourceBonus) + 10
				--TypeMunitionBonus = math.floor(TypeMunitionBonus) + 2
				
			
			end
			
			
			table.remove(t_SpawnedUnitInfo, k)
			
		end
		
	end
	
	g_KillCount = g_KillCount + 1
	
	local l_tempTotal = 0
	
	
	for i = 1, table.getn(t_PlayerHumanInfo) do
		
		Player_AddResource(t_PlayerHumanInfo[i].playerID, RT_Manpower, TypeResourceBonus)
		Player_AddResource(t_PlayerHumanInfo[i].playerID, RT_Munition, TypeMunitionBonus)
	
		t_PlayerHumanInfo[i].individualTotalScore = t_PlayerHumanInfo[i].individualTotalScore + (TypeMultiplier*ScoreMultiplier*OverallScoreMultiplier)	
		
		t_PlayerHumanInfo[i].bonusScore = t_PlayerHumanInfo[i].bonusScore + (TypeMultiplier*ScoreMultiplier*OverallScoreMultiplier)	-- keeps track of bonuses so far
		
		if Game_GetLocalPlayer() == t_PlayerHumanInfo[i].playerID then
		
			local num = Loc_ConvertNumber(TypeResourceBonus)
			local num2 = Loc_ConvertNumber(TypeMunitionBonus)
			local text = Loc_FormatText(10000045, num)
			local text2 = Loc_FormatText(10000046, num2)
			
			
			UI_CreateColouredPositionKickerMessage( t_PlayerHumanInfo[i].playerID, Squad_GetPosition( squad ), text, 189, 161, 68, 0)
			UI_CreateColouredPositionKickerMessage( t_PlayerHumanInfo[i].playerID, Squad_GetPosition( squad ), text2, 198, 120, 74, 0)
			
		end
		
		l_tempTotal = l_tempTotal + t_PlayerHumanInfo[i].individualTotalScore
		print("a kill, so now new score for player "..i.." is "..l_tempTotal)
		print(t_PlayerHumanInfo[i].individualTotalScore)
		print("bonus score is now "..t_PlayerHumanInfo[i].bonusScore)
		
		UpdatePlayerScores(t_PlayerHumanInfo[i].playerID)
		
	end
	
end

-- function to update the player's score based
function UpdatePlayerScores(player, playerInfoTable)
	
	if g_SinglePlayer == true then
		
		UI_SetScoreSingle(10000006, Loc_ConvertNumber(Stats_EntitiesKilled(player)))
		
	else
		
		if Game_GetLocalPlayer() == player then
			
			UI_SetScoreRight(10000006, Loc_ConvertNumber(Stats_EntitiesKilled(player)))
			
		end
		
		UI_SetScoreLeft(10000003, Loc_ConvertNumber(Stats_TeamTally(g_PlayerTeam, Stats_EntitiesKilled)))
		
	end

end



function Rule_UpdateIndividualScore()

	local l_tempTotal = 0


	for k, v in pairs(t_PlayerHumanInfo) do	

		local name = Player_GetDisplayName(v.playerID) 
			
		local l_SquadCountAddition = 0
		
		local l_PlayerKillCountAddition = 0
		
		local l_UnitsLostCountMultiplier = 0
		
		local l_OldSquadCount = v.squadCount
		local l_OldKillCount = v.killCount
		local l_OldUnitsLost = v.unitsLost
		local l_OldIndividualTotalScore = v.individualTotalScore
		
		local l_NewSquadCount = 0
		local l_NewKillCount = 0
		local l_NewUnitsLost = 0
		local l_NewIndividualAdditionWithoutBonus = 0
		
		
		l_NewSquadCount = Player_GetSquadCount(v.playerID)
		
		
		if l_NewSquadCount > l_OldSquadCount then
		
			local l_squadDiff = 0
			
			l_squadDiff = l_NewSquadCount - l_OldSquadCount
			
			
			v.squadCount = l_NewSquadCount
			
			l_SquadCountAddition = 100 * l_squadDiff
			
			v.squadCountScore = v.squadCountScore + l_SquadCountAddition
			

		elseif l_NewSquadCount < l_OldSquadCount then
		
			v.squadCount = l_NewSquadCount
			
		end
		
		l_NewKillCount = Stats_KillsTotal(v.playerID)
		
		if l_NewKillCount > l_OldKillCount then
		
			local l_killDiff = 0
			
			l_killDiff = l_NewKillCount - l_OldKillCount
			
			v.killCount = l_NewKillCount
		
			l_PlayerKillCountAddition = 100 * l_killDiff
			
			v.killCountScore = v.killCountScore + l_PlayerKillCountAddition
			
		end


		-- this part compares the total score to see if it's increased.  if so, then use the new amount
		l_NewIndividualAdditionWithoutBonus = l_SquadCountAddition + l_PlayerKillCountAddition
		
		if v.individualTotalScore + l_NewIndividualAdditionWithoutBonus > l_OldIndividualTotalScore then
		
			v.individualTotalScore = v.individualTotalScore + l_NewIndividualAdditionWithoutBonus
			
			UpdatePlayerScores(v.playerID)
			
		end
		
	end
	
end

-- tracks the team score
function Rule_TrackTotalScore()

	if Objective_IsStarted(OBJ_Defend_HQ) and Objective_IsComplete(OBJ_Defend_HQ) then
	
		Rule_RemoveMe()

	else
		if g_SinglePlayer == true then
			
			UI_SetScoreSingle(10000006, Loc_ConvertNumber(Stats_TeamTally(g_PlayerTeam, Stats_EntitiesKilled)))
			
		else
			
			UI_SetScoreLeft(10000003, Loc_ConvertNumber(Stats_TeamTally(g_PlayerTeam, Stats_EntitiesKilled)))
			
		end
		
	end
	
	local l_tempTotal = 0
	
	-- cycles through each player, and adds their individual scores to the aggregate total
	for k, v in pairs(t_PlayerHumanInfo) do
		
		l_tempTotal = l_tempTotal + v.individualTotalScore
		
	end
		
	-- if this aggregate score is greater than the stated total score value, then use the new value.
	if l_tempTotal > g_TotalScore then
		
		g_TotalScore = l_tempTotal
		
	end

end	


function Creep_OvergroupTrack()
	--t_OvergroupInfo = {}
	--if t_OvergroupInfo ~= nil then
	
	--print(table.getn(t_OverGroupInfo))
	if table.getn(t_OverGroupInfo) > 0 then
			
		for i = 1, table.getn(t_OverGroupInfo) do
		
			--print("Overgroup "..i)
			--print(SGroup_IsEmpty(t_OverGroupInfo[i].name))
			if SGroup_IsEmpty(t_OverGroupInfo[i].name) then
			
				--print("Overgroup "..i.." is empty, removing")
				table.remove(t_OverGroupInfo, i)
				--print(table.getn(t_OverGroupInfo))
				if g_CreepGroupsSpawned > 0 then
					--print("g_CreepGroupsSpawned - 1")
					g_CreepGroupsSpawned = g_CreepGroupsSpawned - 1
				
				end
				break
				
			end
			
		end
		
	end


end

function Creep_VehicleTrack()

	if table.getn(t_VehicleInfo) > 0 then
		
		for k, v in pairs(t_VehicleInfo) do

			--if SGroup_IsEmpty(v.name) == true then
					
				if SGroup_GetAvgHealth(v.name) == 0 then
			
					table.remove(t_VehicleInfo, k)
			
				end
				
			--end
		
		end
	end

end


-- checks to see if the player has met the win objectives
function Rule_CreepWinCheck()

	local currentInfo = t_CreepWaveInfo[g_WaveProgression]
	
	-- if last buildings destroyed, and players have nothing left and can't build any units
	if g_HumansHaveNothing then
		
		-- this delay is so that anything that happens that needs to happen before the objective win/fail actually happens and after the check goes through
		Rule_AddOneShot(Rule_LoseDelay, 5)
		
		Rule_RemoveMe()
		
	-- otherwise if last wave has been sent and no spawned enemies left
	else
		
		if fg_LastWave == true and (g_WaveProgression >= g_CreepWaveCount) and (g_CreepGroupsSpawned >= currentInfo.maxGroupNumber) and fg_EndFlag == true then
			
			local tempSquad = sg_CreepTempSquads
			
			Player_GetAll(g_CreepPlayer, tempSquad)
			
			-- as temporary solution we are using SGroup_CountSpawned, something may be wrong with SGroup_TotalMembersCount (see issue 10478)
			if (SGroup_CountSpawned(tempSquad) == 0) then	
				
				-- this delay is so that anything that happens that needs to happen before the objective win/fail actually happens and after the check goes through
				Rule_AddOneShot(Rule_WinDelay, 5)  
				
				Rule_RemoveMe()
				
			end
			
		end
		
	end
	
end


function Rule_LoseDelay()

	Objective_Fail(OBJ_Defend_HQ)
	
	if Rule_Exists(_CountAvg_Track) then

		_CountAvg_Report()

    end
	
	World_SetTeamWin( Player_GetTeam(g_CreepPlayer), "ZANNIHILATE" )
	
end

function Rule_WinDelay()

	Objective_Complete(OBJ_Defend_HQ)		
	
	if Rule_Exists(_CountAvg_Track) then
		
		_CountAvg_Report()
		
    end

	fe_gameover(Player_GetTeam(Game_GetLocalPlayer()), "stonewall");

	if Player_GetRaceName(g_CreepPlayer) == "allies" then
		
		World_SetTeamWin( Team_FindByRace(TRACE_AXIS), "ZANNIHILATE" )
		
	elseif Player_GetRaceName(g_CreepPlayer) == "axis" then
		
		World_SetTeamWin( Team_FindByRace(TRACE_ALLIES), "ZANNIHILATE" )
		
	end
	
end

function Rule_PlayerBuildingTracker()


	for i = 1, table.getn(t_PlayerHumanInfo) do
		
		if t_PlayerHumanInfo[i].hasNothing == false then
			
			
			-- local building check
			local l_tempBuildingEmpty = EGroup_IsEmpty(t_PlayerHumanInfo[i].building)
			
			-- local secondary building check
			local l_tempSecondaryBuildingEmpty = EGroup_IsEmpty(t_PlayerHumanInfo[i].secondaryBuilding)
			
			
			if t_PlayerHumanInfo[i].hasNothing == false then
				
				--if a building is left, a fellow player might make a kill, giving this player resources which they could potentially use to build
				if l_tempBuildingEmpty == false or l_tempSecondaryBuildingEmpty == false then  
				
				--if no building is left, no matter what resources the player has they can't do anything, so player is "out"
				elseif l_tempBuildingEmpty and l_tempSecondaryBuildingEmpty then 
					t_PlayerHumanInfo[i].hasNothing = true
					
					g_HasNothingCount = g_HasNothingCount + 1
					
					if g_NumberOfHumans > 1 then
					
						g_NumberOfHumans = g_NumberOfHumans - 1 -- updates number of active humans
					
						g_CreepBackupTimer = (90 - (g_NumberOfHumans * 5)) -- updates the timer to compensate for change in number of humans
						
					end
					
				end
				
			end
			
		end
		
		-- if the number of humans that have nothing equals the total number of humans, then the humans lose!
		if g_HasNothingCount >= g_TotalNumberOfHumans then
			
			g_HumansHaveNothing = true
			
		end
		
		
	end
	
end


function Spawn_Ping(SpawnedUnit) -- adds a tactical map ping on the tower for 1 seconds

	Spawn_Ping_ID = UI_CreateMinimapBlip(SpawnedUnit, 1, BT_CombatPing)
	
	
end


function Rule_TargetIndexTracker() -- tracks the next building to attack

	if g_LastBuildingDestroyed == true then
	
		Rule_RemoveMe()
		
		
	else
		
		if EGroup_IsEmpty(t_TargetTable[g_TargetIndexNum].name) == true then
		
			if g_TargetIndexNum >= table.getn(t_TargetTable) then
			
				Rule_RemoveMe()
			
			else
				
				g_TargetIndexNum = g_TargetIndexNum + 1
				
			end
			
		end
		
	end
end


function Rule_TargetStateTracker() -- tracks the state of the building

	if g_LastBuildingDestroyed == true then
		
		Rule_RemoveMe()
		
	else
		-- cycles through the target table
		for i = 1, table.getn(t_TargetTable) do
			
			-- if the target is empty and the flag for its state hasn't been set yet
			if EGroup_IsEmpty(t_TargetTable[i].name) and t_TargetTable[i].destroyed == false then
				
				t_TargetTable[i].destroyed = true -- set flag
				
				print("destroyed")
				PlayInvasionSpeech(Game_GetLocalPlayer(), t_TargetTable[i].destroyedpath)
				
				g_WaveBonusPenalty = g_WaveBonusPenalty + 200	
				
			elseif EGroup_IsEmpty(t_TargetTable[i].name) == false and EGroup_IsUnderAttack(t_TargetTable[i].name, ANY, 1) and t_TargetTable[i].destroyed == false 
				and math.floor(Timer_GetRemaining(t_TargetTable[i].timer)) <= 0 then
				print("building under attack!")
				PlayInvasionSpeech(Game_GetLocalPlayer(), t_TargetTable[i].underattackpath)
				Timer_Start(t_TargetTable[i].timer, 20)
				
			end
			
		end
		
		
		if EGroup_IsEmpty(eg_AllSecondaryBuildings) == true then
		
			g_LastBuildingDestroyed = true
		
		end
		
		
	end
end



function Rule_HQStateTracker() -- tracks the state of the building

	local l_local_player = Game_GetLocalPlayer()
	
	-- cycles through the target table
	--for i = 1, table.getn(t_PlayerHumanInfo) do
	for k, v in pairs(t_PlayerHumanInfo) do	
			-- if the target is empty and the flag for its state hasn't been set yet
		if EGroup_IsEmpty(v.building) and v.destroyed == false and (Game_GetLocalPlayer() == v.owner) then
			
			v.destroyed = true -- set flag
			
			print("HQ destroyed")
			PlayInvasionSpeech(l_local_player, v.destroyedpath)
			
		elseif EGroup_IsEmpty(v.building) == false and EGroup_IsUnderAttack(v.building, ANY, 1) and v.destroyed == false 
			and math.floor(Timer_GetRemaining(v.timer)) <= 0 and Player_OwnsEGroup(l_local_player, v.building, ANY) then
			
			if  (EGroup_GetAvgHealth(v.building) > 0.25) then
				
				print("HQ under attack!")
				PlayInvasionSpeech(l_local_player, v.underattackpath)
				Timer_Start(v.timer, 20)
				
			elseif (EGroup_GetAvgHealth(v.building) <= 0.25) then
				
				print("HQ low health!")
				PlayInvasionSpeech(l_local_player, v.lowhealthpath)
				Timer_Start(v.timer, 20)
				
			end
		end	
	end
end


function Rule_CreepDropSmoke()

	print("smoke!")
	local creepProgression = t_CreepWaveInfo[g_WaveProgression]
	
	if creepProgression.boss == false and creepProgression.lastboss == false then	
	
		local l_random_position = Util_GetRandomPosition(g_CreepSpawnLocation)
		
		Cmd_Ability(g_CreepPlayer, ABILITY.SP.SINGLE_MORTAR_SMOKE, l_random_position, nil, false)
		
		Rule_WarningTextArrow()
	
	elseif creepProgression.boss == true or creepProgression.lastboss == true then
		
		for z = 1, table.getn(t_RandomBossSpawn) do
			
			local l_random_position = Util_GetRandomPosition(t_RandomBossSpawn[z].spawnlocation)
			
			Cmd_Ability(g_CreepPlayer, ABILITY.SP.SINGLE_MORTAR_SMOKE, l_random_position, nil, false)
			--Rule_WarningTextArrow()
			
		end
	end
	
end


function Rule_WarningTextArrow()
	
	local warningtext = ""

	for i = 1, table.getn(t_SpawnLocationsAndGoals) do
		
		if g_CreepSpawnLocation == t_SpawnLocationsAndGoals[i].spawnlocation then
			
			g_GeneralThreatLocation = t_SpawnLocationsAndGoals[i].spawnlocation
			warningtext = t_SpawnLocationsAndGoals[i].text
			break
			
		end
		
	end
	
	UIWarning_Show(warningtext)
	
	ThreatArrow_Add(g_GeneralThreatID, g_GeneralThreatLocation)
	
	if Rule_Exists(Rule_ThreatArrowRemove) == false then
		
		Rule_AddOneShot(Rule_ThreatArrowRemove, 15)
		
	end


end


function Rule_ThreatArrowRemove()

	ThreatArrow_Remove(g_GeneralThreatID, g_GeneralThreatLocation)
	--g_GeneralThreatID = ThreatArrow_CreateGroup()
end

function Rule_CreepDropArtillery()
	
	local tempSGroup = sg_tempSGroup
	local tempEGroup = eg_tempEGroup
	local overallSGroup = sg_overallSGroup
	local overallEGroup = eg_overallEGroup
	local artMarker = 1
	local spawnDelay = 3
	local creepProgression = t_CreepWaveInfo[g_WaveProgression]
	local bossArtillery = false
	
	-- grabs enemies in spawn locations to kill!
	if creepProgression.boss == false and creepProgression.lastboss == false then
		
		if EGroup_IsEmpty(t_SpawnLocationsAndGoals[g_SpawnIndex].defaulttarget) == true then
			
			artMarker = 2
			
		end
		
		for i = 1, table.getn(t_PlayerHumanInfo) do
			
			
			Player_GetAllSquadsNearMarker(t_PlayerHumanInfo[i].playerID, tempSGroup, t_SpawnLocationsAndGoals[g_SpawnIndex].artillery[artMarker])
			
			if SGroup_IsEmpty(tempSGroup) == false then
			
				SGroup_AddGroup(overallSGroup, tempSGroup)
				SGroup_Clear(tempSGroup)
				
			end
			
			
			Player_GetAllEntitiesNearMarker(t_PlayerHumanInfo[i].playerID, tempEGroup, t_SpawnLocationsAndGoals[g_SpawnIndex].artillery[artMarker])
			
			if EGroup_IsEmpty(tempEGroup) == false then
				
				
				EGroup_Filter(tempEGroup, EBP.SP.GARAGE_INVASION, FILTER_REMOVE)
				EGroup_Filter(tempEGroup, EBP.SP.CHURCH_INVASION, FILTER_REMOVE)
				EGroup_Filter(tempEGroup, EBP.SP.MANOR_INVASION, FILTER_REMOVE)
				EGroup_Filter(tempEGroup, EBP.SP.BANK_INVASION, FILTER_REMOVE)
				
				EGroup_AddEGroup(overallEGroup, tempEGroup)
				EGroup_Clear(tempEGroup)
				
			end
			
		end
		
	elseif creepProgression.boss == true or creepProgression.lastboss == true then
		
		bossArtillery = true
		
		local numOfSpawnLoc = 2
		
		if creepProgression.lastboss == true then
			
			numOfSpawnLoc = 4
			
		end
		-- checking to see if t_RandomBossSpawn has reset.  t_RandomBossSpawn resets after every subwave
		-- once it is reset, it needs to be repopulated again before artillery and spawn points can be determined
		if table.getn(t_RandomBossSpawn) < numOfSpawnLoc then
			
			t_RandomBossSpawn = Table_GetRandomItem(t_SpawnLocationsAndGoals, numOfSpawnLoc) 
			
		end
		
	end
	
	if bossArtillery == true then
		
		for z = 1, table.getn(t_RandomBossSpawn) do
			-- checks to see if outpost building associated with the spawn point is destroyed.
			-- if it is, then expand the area for artillery.
			if EGroup_IsEmpty(t_RandomBossSpawn[z].defaulttarget) == true then
				
				artMarker = 2
				
			end
			
			for p = 1, artMarker do
				
				for i = 1, table.getn(t_PlayerHumanInfo) do
					
					Player_GetAllEntitiesNearMarker(t_PlayerHumanInfo[i].playerID, tempEGroup, t_RandomBossSpawn[z].artillery[artMarker])
					
					if EGroup_IsEmpty(tempEGroup) == false then
						
						EGroup_Filter(tempEGroup, EBP.SP.GARAGE_INVASION, FILTER_REMOVE)
						EGroup_Filter(tempEGroup, EBP.SP.CHURCH_INVASION, FILTER_REMOVE)
						EGroup_Filter(tempEGroup, EBP.SP.MANOR_INVASION, FILTER_REMOVE)
						EGroup_Filter(tempEGroup, EBP.SP.BANK_INVASION, FILTER_REMOVE)
						
						EGroup_AddEGroup(overallEGroup, tempEGroup)
						EGroup_Clear(tempEGroup)
					end
					
				end	
				
				-- drop artillery vs. EGroups.  They have priority over Sgroups				
				if EGroup_IsEmpty(overallEGroup) == false then
					
					Cmd_Ability(g_CreepPlayer, ABILITY.COHO.UMS.INVASION.CREEP_OFFMAP_ARTILLERY, Entity_GetPosition(EGroup_GetRandomSpawnedEntity(overallEGroup)), nil, false)
					
					EGroup_Clear(overallEGroup)
					spawnDelay = 23
					
				else
					-- drop artillery vs. Sgroups.  Checks to see if any of the creep are near the blast area, and if not then drop artillery.
					
					if Prox_ArePlayersNearMarker(g_CreepPlayer, t_RandomBossSpawn[z].artillery[artMarker], ANY) == false then
						
						Cmd_Ability(g_CreepPlayer, ABILITY.COHO.UMS.INVASION.CREEP_OFFMAP_ARTILLERY, Marker_GetPosition(t_RandomBossSpawn[z].artillery[artMarker]), nil, false)
						SGroup_Clear(sg_proxSquads)	
						spawnDelay = 23
						
					end
					
				end
				
			end
			
		end
		
	elseif bossArtillery == false then
		
		if (EGroup_IsEmpty(overallEGroup) == false) then
			
			Cmd_Ability(g_CreepPlayer, ABILITY.COHO.UMS.INVASION.CREEP_OFFMAP_ARTILLERY, Entity_GetPosition(EGroup_GetRandomSpawnedEntity(overallEGroup)), nil, false)
			
			spawnDelay = 23
			
			EGroup_Clear(overallEGroup)
			
		elseif (SGroup_IsEmpty(overallSGroup) == false) then
			
			Cmd_Ability(g_CreepPlayer, ABILITY.COHO.UMS.INVASION.CREEP_OFFMAP_ARTILLERY, Squad_GetPosition(SGroup_GetRandomSpawnedSquad(overallSGroup)), nil, false)
			
			spawnDelay = 23
			
			SGroup_Clear(overallSGroup)
			
		end
		
	end
	
	if creepProgression.boss == false and creepProgression.lastboss == false then
		
		-- smoke and ping determined here if not boss wave
		local randSmokeNum = World_GetRand(2, 3) -- number of smoke mortars that appeaer
		Rule_AddDelayedIntervalEx(Rule_CreepDropSmoke, spawnDelay, 1, randSmokeNum)
		
		Spawn_NotifyID = UI_CreateMinimapBlip(g_CreepSpawnLocation, spawnDelay + 8, BT_CombatPing)
		
		FOW_RevealArea(Marker_GetPosition(g_CreepSpawnLocation), 25, (spawnDelay + 20))
		
	elseif creepProgression.boss == true or creepProgression.lastboss == true then
		
		-- smoke and pings get called here if boss wave
		local randSmokeNum = World_GetRand(2, 3) -- number of smoke mortars that appeaer
		
		for z = 1, table.getn(t_RandomBossSpawn) do
		
			Spawn_NotifyID = UI_CreateMinimapBlip(t_RandomBossSpawn[z].artillery[1], spawnDelay + 8, BT_CombatPing)
			
			FOW_RevealArea(Marker_GetPosition(t_RandomBossSpawn[z].artillery[1]), 25, (spawnDelay + 20))
			
		end
		
		Rule_AddDelayedIntervalEx(Rule_CreepDropSmoke, spawnDelay, 1, randSmokeNum)	
		
	end
	
	Rule_AddDelayedInterval(Rule_CreepSpawnCreation, (spawnDelay + 8), 4) 
	
	Rule_RemoveMe()

end


function DisplayCurrentWave()

	if g_WaveProgression <= g_CreepWaveCount then
		
		local outOf = Loc_ConvertNumber(g_CreepWaveCount)
		local wave = Loc_ConvertNumber(g_WaveProgression)
		
		local waveText = Loc_FormatText(10000053, wave, outOf)
		
		Util_MissionTitle(waveText)
		
	end

end


function Rule_PlayBossSpeech()

	local val = t_CreepWaveInfo[g_WaveProgression].bossnumber
	print("value is "..val)
	if val ~= false or val ~= nil then
		print("boss speech should be played!")
		PlayInvasionSpeech(Game_GetLocalPlayer(), t_BossSpawnSpeech[val])
		
	end
	
end

function Rule_InvasionBonusScoring()

	local l_HighestScore = 0
	local l_ComparisonScore = 0
	local l_HighestScorePlayer = false
	--for i = 1, table.getn(t_PlayerHumanInfo) do
	
	for k, v in pairs(t_PlayerHumanInfo) do	
	
		local name = Player_GetDisplayName(v.playerID) 
		print(Loc_ToAnsi2(name))
		
		local l_SquadCountMultiplier = 1
		
		local l_PlayerKillCountMultiplier = 1
		
		local l_UnitsLostCountMultiplier = 0
		
		
		
		print("--------")
		
		v.squadCount = Player_GetSquadCount(v.playerID)
		
		if (v.squadCount >= 0) and (v.squadCount <= 5) then 
		
			l_SquadCountMultiplier = 100
			
		elseif (v.squadCount >= 6) and (v.squadCount <= 10) then 
		
			l_SquadCountMultiplier = 200
			
		end
		
		print(Loc_ToAnsi2(name).."'s surviving squad count is "..v.squadCount)
		print("Multiplier is "..l_SquadCountMultiplier)
		
		v.squadCountScore = v.squadCount * l_SquadCountMultiplier 
		
		print("Squad count bonus score is: "..v.squadCount.." X "..l_SquadCountMultiplier.." = "..v.squadCountScore) 
		

		v.killCount = Stats_KillsTotal(v.playerID)
		
		if (v.killCount >= 0) and (v.killCount <= 30) then
			
			l_PlayerKillCountMultiplier = 100
			
			print(Loc_ToAnsi2(name).." is a slacker.  They've only killed "..v.killCount.." enemy soldiers and vehicles!")
			print("Multiplier is "..l_PlayerKillCountMultiplier)
			
			v.killCountScore = v.killCount * l_PlayerKillCountMultiplier
			
			print("Kill count bonus score is: "..v.killCount.." X "..l_PlayerKillCountMultiplier.." = "..v.killCountScore) 
			
		elseif (v.killCount >= 31) and (v.killCount <= 60) then 
			
			l_PlayerKillCountMultiplier = 200
			
			print(Loc_ToAnsi2(name).." is doing well.  They've killed "..v.killCount.." enemy soldiers and vehicles!")
			print("Multiplier is "..l_PlayerKillCountMultiplier)
			
			v.killCountScore = v.killCount * l_PlayerKillCountMultiplier
			
			print("Kill count bonus score is: "..v.killCount.." X "..l_PlayerKillCountMultiplier.." = "..v.killCountScore) 
			
		elseif (v.killCount >= 61) and (v.killCount <= 90) then 
			
			l_PlayerKillCountMultiplier = 300
			
			print(Loc_ToAnsi2(name).." is a killer!  They've killed "..v.killCount.." enemy soldiers and vehicles!")
			print("Multiplier is "..l_PlayerKillCountMultiplier)
			
			v.killCountScore = v.killCount * l_PlayerKillCountMultiplier
			
			print("Kill count bonus score is: "..v.killCount.." X "..l_PlayerKillCountMultiplier.." = "..v.killCountScore) 
			
			
		elseif (v.killCount >= 91)  then 
			
			l_PlayerKillCountMultiplier = 400
			
			print(Loc_ToAnsi2(name).." is a machine!  They've killed "..v.killCount.." enemy soldiers and vehicles!")
			print("Multiplier is "..l_PlayerKillCountMultiplier)
			
			v.killCountScore = v.killCount * l_PlayerKillCountMultiplier
			
			print("Kill count bonus score is: "..v.killCount.." X "..l_PlayerKillCountMultiplier.." = "..v.killCountScore) 	
			
		end
		
		v.unitsLost = Stats_TotalSquadsLost(v.playerID) + Stats_VehiclesLost(v.playerID)
		
		if (v.unitsLost >= 0) and (v.unitsLost <= 10) then
		
			l_UnitsLostCountMultiplier = 0
			
			print(Loc_ToAnsi2(name).." lost only "..v.unitsLost.." squads and vehicles!  Command will be pleased their efficiency!")
			print("Penalty Multiplier is "..l_PlayerKillCountMultiplier)
			
			v.unitsLostPenalty = v.unitsLost * l_UnitsLostCountMultiplier
			
			print("Units Lost count penalty is: "..v.unitsLost.." X "..l_UnitsLostCountMultiplier.." = "..v.unitsLostPenalty) 	
		
		
		elseif (v.unitsLost >= 11) and (v.unitsLost <= 30) then
		
			l_UnitsLostCountMultiplier = 100
			
			print(Loc_ToAnsi2(name).." lost "..v.unitsLost.." squads and vehicles... Average efficiency!")
			print("Penalty Multiplier is "..l_PlayerKillCountMultiplier)
			
			v.unitsLostPenalty = v.unitsLost * l_UnitsLostCountMultiplier
			
			print("Units Lost count penalty is: "..v.unitsLost.." X "..l_UnitsLostCountMultiplier.." = "..v.unitsLostPenalty) 	
			
		elseif (v.unitsLost >= 31) then
		
			l_UnitsLostCountMultiplier = 200
			
			print(Loc_ToAnsi2(name).." lost "..v.unitsLost.." squads and vehicles... Command hates incompetence!")
			print("Penalty Multiplier is "..l_PlayerKillCountMultiplier)
			
			v.unitsLostPenalty = v.unitsLost * l_UnitsLostCountMultiplier	
			
			print("Units Lost count penalty is: "..v.unitsLost.." X "..l_UnitsLostCountMultiplier.." = "..v.unitsLostPenalty) 	
		
		end
		
		
		v.individualTotalScore = v.individualTotalScore + v.squadCountScore + v.killCountScore - v.unitsLostPenalty
		
		
		print("Final Score for "..Loc_ToAnsi2(name).." is: "..v.individualTotalScore..". (Team Score + Bonus Squad Count + Bonus Kill Count - Units Lost Penalty)")
		
		l_ComparisonScore = v.individualTotalScore
		
		print("--------")
		
		
		if l_ComparisonScore > l_HighestScore then
		
			l_HighestScore = l_ComparisonScore
			
			l_HighestScorePlayer = v.playerID
			
		end
		
		
		
	end
	
	if l_HighestScorePlayer == false then

	
	else
	
		local l_PlayerStringName = Player_GetDisplayName(l_HighestScorePlayer) 
			
			
		print("Congratulations, "..Loc_ToAnsi2(l_PlayerStringName)..".  You have the highest score with "..l_HighestScore.." points!")
		
	end

end



function Rule_CreepSpawnValueDeterminer() 
	
	
	
	t_CreepInfantryUnitValue = {
	
		{blueprint = SBP.ALLIES.RIFLEMEN, value = 1},
		{blueprint = SBP.ALLIES.ENGINEER, value = 2},
		{blueprint = SBP.ALLIES.RANGER, value = 3},
		{blueprint = SBP.ALLIES.HEAVYMG, value = 4},
		{blueprint = SBP.ALLIES.SNIPER, value = 5},
		{blueprint = SBP.ALLIES.MORTAR, value = 6},
		
		{blueprint = SBP.AXIS.VOLKSGRENADIER, value = 1},
		{blueprint = SBP.AXIS.PIONEER, value = 2},
		{blueprint = SBP.AXIS.GRENADIER, value = 3},
		{blueprint = SBP.AXIS.HEAVYMG, value = 4},
		{blueprint = SBP.AXIS.SNIPER, value = 5},
		{blueprint = SBP.AXIS.MORTAR, value = 6},
	
	
	}
	
	t_CreepVehicleUnitValue = {
	
		{blueprint = SBP.ALLIES.JEEP, value = 1},
		{blueprint = SBP.ALLIES.GREYHOUND, value = 4},
		{blueprint = SBP.COHO.INVASION_ALLIES_NEBELWERFER, value = 3},
		{blueprint = SBP.ALLIES.M10, value = 4},
		{blueprint = SBP.ALLIES.SHERMAN, value = 5},
		{blueprint = SBP.ALLIES.AT_57MM, value = 4},
		{blueprint = SBP.ALLIES.PERSHING, value = 6},
		
		{blueprint = SBP.AXIS.MOTORCYCLE, value = 1},
		{blueprint = SBP.AXIS.PUMA, value = 4},
		{blueprint = SBP.COHO.INVASION_AXIS_NEBELWERFER, value = 3},
		{blueprint = SBP.AXIS.STUG, value = 4},
		{blueprint = SBP.AXIS.PANZER, value = 5},
		{blueprint = SBP.AXIS.PANTHER, value = 6},
		{blueprint = SBP.AXIS.TIGER, value = 7},

	
	}
	local l_InfantryValue = 0
	local l_VehicleValue = 0
	local _CheckSquad = function( sgroupid, itemindex, squadID )
		if World_OwnsSquad(squadID) == false then
			
			local blueprint = Squad_GetBlueprint(squadID)				
				
				for k,v in pairs(t_CreepInfantryUnitValue) do
				
					if blueprint == v.blueprint then
						
						l_InfantryValue = l_InfantryValue + v.value
						print("infantry subtotal = "..l_InfantryValue)
					
						
					end
				
				end
		end
	end
	local _CheckVehicle = function( sgroupid, itemindex, squadID )
		if World_OwnsSquad(squadID) == false then
			
			local blueprint = Squad_GetBlueprint(squadID)				
				
				for k,v in pairs(t_CreepVehicleUnitValue) do
				
					if blueprint == v.blueprint then
						
						l_VehicleValue = l_VehicleValue + v.value
						print("vehicle subtotal = "..l_VehicleValue)	
					end
				
				end
		end
	end	
		
	Player_GetAll(g_CreepPlayer)
		
	local l_tempcon = sg_allsquads
		
	if l_tempcon == nil then
	
	else
		
		if SGroup_IsEmpty(l_tempcon) == false then
		
			SGroup_ForEach(l_tempcon, _CheckSquad)
			SGroup_ForEach(l_tempcon, _CheckVehicle)
			print("human 1 infantry = "..l_InfantryValue)
			print("human 1 vehicle = "..l_VehicleValue)
		end
	end

	
	return (l_InfantryValue + l_VehicleValue)
	
end


-- skeleton function for adding abilities to the players
function Rule_SpecialAbilityAddition()
	
	for k, v in pairs(t_PlayerHumanInfo) do
	
		if Player_GetRaceName(v.playerID) == TRACE_ALLIES then
		
			if v.abilityStatus[1] == false and g_WaveProgression == 5 then
				
				v.currentAbility = ABILITY.COHO.UMS.INVASION.UNIVERSAL_SUPPLY_DROP
				Invasion_FlashAndHintAbilityReward( v.playerID, v.currentAbility )
				v.abilityStatus[1] = true
				
				if Rule_Exists(Invasion_FlashAndHintAbilityAdd) == false then
				
					Rule_AddOneShot(Invasion_FlashAndHintAbilityAdd, 1)
				
				end
				
				if Rule_Exists(Rule_CommanderTreeHintpointEnd) == false then
					
					Rule_AddOneShot(Rule_CommanderTreeHintpointEnd, 10)
				
				end
				
			elseif v.abilityStatus[2] == false and g_WaveProgression == 8 then

				
				v.currentAbility = ABILITY.COHO.UMS.INVASION.ALLY_STRAFING_RUN
				Invasion_FlashAndHintAbilityReward( v.playerID, v.currentAbility )
				v.abilityStatus[2] = true
				
				if Rule_Exists(Invasion_FlashAndHintAbilityAdd) == false then
				
					Rule_AddOneShot(Invasion_FlashAndHintAbilityAdd, 1)
				
				end
				
				if Rule_Exists(Rule_CommanderTreeHintpointEnd) == false then
					
					Rule_AddOneShot(Rule_CommanderTreeHintpointEnd, 10)
				
				end
				
			elseif v.abilityStatus[3] == false and g_WaveProgression == 11 then
			
				v.currentAbility = ABILITY.COHO.UMS.INVASION.ALLY_BOMBING_RUN
				Invasion_FlashAndHintAbilityReward( v.playerID, v.currentAbility )
				v.abilityStatus[3] = true
				
				if Rule_Exists(Invasion_FlashAndHintAbilityAdd) == false then
				
					Rule_AddOneShot(Invasion_FlashAndHintAbilityAdd, 1)
				
				end
				
				if Rule_Exists(Rule_CommanderTreeHintpointEnd) == false then
					
					Rule_AddOneShot(Rule_CommanderTreeHintpointEnd, 10)
				
				end
				
			elseif v.abilityStatus[4] == false and g_WaveProgression == 14 then	

				v.currentAbility = ABILITY.COHO.UMS.INVASION.ALLY_HOWITZER
				Invasion_FlashAndHintAbilityReward( v.playerID, v.currentAbility )
				v.abilityStatus[4] = true
				
				if Rule_Exists(Invasion_FlashAndHintAbilityAdd) == false then
				
					Rule_AddOneShot(Invasion_FlashAndHintAbilityAdd, 1)
				
				end
				
				if Rule_Exists(Rule_CommanderTreeHintpointEnd) == false then
					
					Rule_AddOneShot(Rule_CommanderTreeHintpointEnd, 10)
				
				end
			end
			
		elseif Player_GetRaceName(v.playerID) == TRACE_AXIS then
			
			
			if v.abilityStatus[1] == false and g_WaveProgression == 5 then
	
				
				v.currentAbility = ABILITY.COHO.UMS.INVASION.UNIVERSAL_SUPPLY_DROP
				Invasion_FlashAndHintAbilityReward( v.playerID, v.currentAbility )
				v.abilityStatus[1] = true
				
				if Rule_Exists(Invasion_FlashAndHintAbilityAdd) == false then
				
					Rule_AddOneShot(Invasion_FlashAndHintAbilityAdd, 1)
				
				end
				
				if Rule_Exists(Rule_CommanderTreeHintpointEnd) == false then
					
					Rule_AddOneShot(Rule_CommanderTreeHintpointEnd, 10)
				
				end
				
				
			elseif v.abilityStatus[2] == false and g_WaveProgression == 8 then
				
				v.currentAbility = ABILITY.COHO.UMS.INVASION.AXIS_FIRESTORM
				Invasion_FlashAndHintAbilityReward( v.playerID, v.currentAbility )
				v.abilityStatus[2] = true
				
				if Rule_Exists(Invasion_FlashAndHintAbilityAdd) == false then
				
					Rule_AddOneShot(Invasion_FlashAndHintAbilityAdd, 1)
				
				end
				
				if Rule_Exists(Rule_CommanderTreeHintpointEnd) == false then
					
					Rule_AddOneShot(Rule_CommanderTreeHintpointEnd, 10)
				
				end
				
			elseif v.abilityStatus[3] == false and g_WaveProgression == 11 then

				v.currentAbility = ABILITY.COHO.UMS.INVASION.AXIS_V1
				Invasion_FlashAndHintAbilityReward( v.playerID, v.currentAbility )
				v.abilityStatus[3] = true
				
				if Rule_Exists(Invasion_FlashAndHintAbilityAdd) == false then
				
					Rule_AddOneShot(Invasion_FlashAndHintAbilityAdd, 1)
				
				end
				
				if Rule_Exists(Rule_CommanderTreeHintpointEnd) == false then
					
					Rule_AddOneShot(Rule_CommanderTreeHintpointEnd, 10)
				
				end
				
			elseif v.abilityStatus[4] == false and g_WaveProgression == 14 then	
				
				v.currentAbility = ABILITY.COHO.UMS.INVASION.AXIS_ROCKET_BARRAGE
				Invasion_FlashAndHintAbilityReward( v.playerID, v.currentAbility )
				
				v.abilityStatus[4] = true
				
				if Rule_Exists(Invasion_FlashAndHintAbilityAdd) == false then
				
					Rule_AddOneShot(Invasion_FlashAndHintAbilityAdd, 1)
				
				end
				
				if Rule_Exists(Rule_CommanderTreeHintpointEnd) == false then
					
					Rule_AddOneShot(Rule_CommanderTreeHintpointEnd, 10)
				
				end
				
			end
			
		end
		
		
		
	
	
	end
	
	
	
end

function Invasion_FlashAndHintAbilityReward( playerID, ability )

	Player_AddAbility(playerID, ability)
	Player_SetAbilityAvailability(playerID, ability, ITEM_DEFAULT)
	
end


function Invasion_FlashAndHintAbilityAdd()
	
	for k, v in pairs(t_PlayerHumanInfo) do
		
		if Game_GetLocalPlayer() == v.playerID then
			v.hintID = HintPoint_AddToAbilityButton(v.currentAbility, 10000066, true)
			v.abilityFlashID = UI_FlashAbilityButton(v.currentAbility, true, BT_UI_Strong_AbilityBtn)
			
		end
	end
	
end


function Rule_CommanderTreeHintpointEnd()
	
	for k, v in pairs(t_PlayerHumanInfo) do
		
		if Game_GetLocalPlayer() == v.playerID then
		
			if v.abilityFlashID ~= nil  then
				UI_StopFlashing(v.abilityFlashID)
			end
		
		end
		
	end
	
	HintPoint_RemoveAll()


end


---------------
--SPEECH--
---------------
function PlayInvasionTypeDetermine(consistsof)

	local l_speechtypepath = ""
	
	local creepProgression = t_CreepWaveInfo[g_WaveProgression]
	
	if creepProgression.boss == false and creepProgression.lastboss == false then	

	
		if consistsof == "infantry" then
			
			for k, v in pairs(t_InfCardinalDirections) do
			
				if g_CreepSpawnDirection == v.dir and (g_CreepSpawnDirection ~= nil or g_CreepSpawnDirection ~= false) then
					
					l_speechtypepath = v.path
					
					break
				
				end
				
			end

		elseif consistsof == "armor" then
			
			for k, v in pairs(t_ArmCardinalDirections) do
			
				if g_CreepSpawnDirection == v.dir and (g_CreepSpawnDirection ~= nil or g_CreepSpawnDirection ~= false) then
					
					l_speechtypepath = v.path
					
					break
				
				end
				
			end
		
		elseif consistsof == "lightarmor" then
			
			for k, v in pairs(t_LightArmCardinalDirections) do
			
				if g_CreepSpawnDirection == v.dir and (g_CreepSpawnDirection ~= nil or g_CreepSpawnDirection ~= false) then
					
					l_speechtypepath = v.path
					
					break
				
				end
				
			end
		
		end
		
		PlayInvasionSpeech(Game_GetLocalPlayer(), l_speechtypepath)
		
	elseif creepProgression.boss == true or creepProgression.lastboss == true then	
	
		Rule_AddOneShot(Rule_PlayBossSpeech, 0)
	
	
	end
end

	
function PlayInvasionSpeech(player, speechPath)
	if type(speechPath) == "table" then
		if type(speechPath.speech) == "string" then
			Sound_Play2D(speechPath.speech)
		elseif Invasion_IsAllies(player) and type(speechPath.allies) == "table" then
			if type(speechPath.allies.speech) == "string" then
				Sound_Play2D(speechPath.allies.speech)
			else
				bug("Expected a string to play sound, not a "..type(speechPath.allies.speech))
			end
		elseif Invasion_IsAxis(player) and type(speechPath.axis) == "table" then
			if type(speechPath.axis.speech) == "string" then
				Sound_Play2D(speechPath.axis.speech)
			else
				bug("Expected a string to play sound, not a "..type(speechPath.axis.speech))
			end
		end
	else
		Util_PrintObject(speechPath)
		bug("Invalid sound data was passed in to play speech. See logs for what was passed in.")
	end
end


function Invasion_IsAllies(player)
	if Player_GetRaceName(player) == TRACE_ALLIES or Player_GetRaceName(player) == TRACE_ALLIES_COMMONWEALTH then
		return true
	elseif Player_GetRaceName(player) == TRACE_AXIS or Player_GetRaceName(player) == TRACE_AXIS_PANZER_ELITE then
		return false
	else
		print("Invasion Team Check doesn't identify any race that isn't in Opposing Fronts, please update script")
		return false
	end
end 


function Invasion_IsAxis(player)
	if Player_GetRaceName(player) == TRACE_AXIS or Player_GetRaceName(player) == TRACE_AXIS_PANZER_ELITE then
		return true
	elseif Player_GetRaceName(player) == TRACE_ALLIES or Player_GetRaceName(player) == TRACE_ALLIES_COMMONWEALTH then
		return false
	else
		print("Invasion Team Check doesn't identify any race that isn't in Opposing Fronts, please update script")
		return false
	end
end

function Invasion_PrecacheSound()
	
	-- set up the global sound cache to prevent improper audio from conflicting
	-- with custom Intel speech.
	Sound_SetGlobalControlSource("GameType", SOUND_SOURCE.STONEWALL)
	
	SoundPrecacheRecursive(soundData, "speech")
end


function SoundPrecacheRecursive(tablePath, keyValidation)
	local stack = {}
	
	_soundPrecacheRecursive = function(path, pathKey)
		if type(path) == "string" then
			if pathKey == keyValidation then
				Sound_PreCacheSound(path)
			end
			
		elseif type(path) == "table" then
			for newPathKey, newPath in pairs(path) do
				local canDo = true
				for k2, stackpile in pairs(stack) do
					
					if newPath == stackpile then
						canDo = false
						break
					end
				end
				
				if canDo then
					table.insert(stack, newPath)
					_soundPrecacheRecursive(newPath, newPathKey)
				end
				
			end
		end
	end
	
	if type(tablePath) == "table" then
		_soundPrecacheRecursive(tablePath)
	end
end





-------------------------
-- Added Feb 17th by Ryan



function BaseChecker() -- Function to keep an eye on player bases
	
	sg_r_allPlayerSquads = SGroup_CreateIfNotFound("sg_r_allPlayerSquads")
	t_aliveBases = { }
	
	for i = 1, table.getn(teg_StuffSpawn) do -- Iterate through table of bases to check if they're destroyed
		if EGroup_IsEmpty(teg_StuffSpawn[i]) == false then
			table.insert(t_aliveBases, teg_StuffSpawn[i]) -- Add any living bases to the alivebases table
		end
	end
	
	if table.getn(t_aliveBases) == 0 then -- if there are no bases that are alive, move on to checking player squads
		local count = 0
		for k, v in pairs(t_PlayerHumanInfo) do
			count = count + Player_GetCurrentPopulation(v.playerID, CT_Vehicle)
			count = count + Player_GetCurrentPopulation(v.playerID, CT_Personnel)
		end
		
		if SGroup_IsEmpty(sg_allKillTeams) then -- flag to setup if kill teams are alive or not
			g_killTeamAlive = false
		else
			g_killTeamAlive = true
		end
		
		if count == 0 and g_killTeamAlive ~= true then -- If there are no player units on the map, start spawning kill teams
			if Rule_Exists(KillTeamSpawn) == false then
				Rule_AddInterval(KillTeamSpawn, 5)
			end
			if Rule_Exists(KillTeamManager) == false then
				Rule_AddInterval(KillTeamManager, 7)
			end
		elseif count >= 1 then -- If there is at least one player unit alive, do not spawn any kill teams
			Rule_Remove(KillTeamSpawn)
		end
	end
	
end

function KillTeamInit() -- Init function for the Kill Team
	
	t_killTeamSpawns = {mkr_CreepSpawn1, mkr_CreepSpawn2, mkr_CreepSpawn3, mkr_CreepSpawn4, mkr_CreepSpawn5, mkr_CreepSpawn6} -- Kill team spawn points
	g_killTeamAlive = false -- Kill team alive or dead 
	sg_allKillTeams = SGroup_CreateIfNotFound("sg_allKillTeams") -- All kill team sgroup

	tsg_killTeam = SGroup_CreateTable("sg_killTeam", 4) -- Table of kill team sgroups 
	
	g_currKillTeam = 0 -- How many kill teams are alive

end


function KillTeamSpawn()
	
	-- First, we need to know which targets are still valid
	-- The first loop handles spawning units initially
	for k, this in pairs(t_TargetTable) do
		if this.destroyed == false and EGroup_IsEmpty(this.name) == false then -- Building is alive, we have a target
			local spawn = Util_GetClosestMarker(EGroup_GetPosition(this.name), t_killTeamSpawns)
			
			for i = 1, table.getn(tsg_killTeam) do
				if SGroup_IsEmpty(tsg_killTeam[i]) then
					if Player_GetRaceName(g_CreepPlayer) == TRACE_ALLIES then
						Util_CreateSquads(g_CreepPlayer, tsg_killTeam[i], SBP.ALLIES.SHERMAN, spawn, this.name, 1)
						
					elseif Player_GetRaceName(g_CreepPlayer) == TRACE_AXIS then
						Util_CreateSquads(g_CreepPlayer, tsg_killTeam[i], SBP.AXIS.PANTHER, spawn, this.name, 1)
						
					end
					SGroup_AddGroup(sg_allKillTeams, tsg_killTeam[i])
					Cmd_Attack(tsg_killTeam[i], this.name)
					break
				end
			end
			
			
		end
	end

end

function KillTeamManager()
	
	for i = 1, table.getn(tsg_killTeam) do
		if SGroup_IsEmpty(tsg_killTeam[i]) == false then
			if SGroup_IsDoingAttack(tsg_killTeam[i], ALL, 7) == false and SGroup_IsMoving(tsg_killTeam[i], ALL) == false then
				
				t_possibleTargets = { }
				
				for k, this in pairs(t_TargetTable) do
					if this.destroyed == false then
						
						table.insert(t_possibleTargets, this)
						
					end
				end
				
				local size = table.getn(t_possibleTargets)
				
				if size >= 1 then
					local target = World_GetRand(1, size)
					
					Cmd_Attack(tsg_killTeam[i], t_possibleTargets[target].name)
				end
				
			end
		end
	end

end


